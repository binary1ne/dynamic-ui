Directory structure:
└── backend/
    ├── README.md
    ├── app.py
    ├── requirements.txt
    ├── configs/
    │   └── app_config.py
    ├── controllers/
    │   ├── __init__.py
    │   ├── app_controllers/
    │   │   ├── agentic/
    │   │   │   └── agentic_controller.py
    │   │   └── guardrails/
    │   │       └── guardrails_controller.py
    │   ├── authentication/
    │   │   └── auth_controller.py
    │   ├── frontend/
    │   │   └── ui_controller.py
    │   └── .scrap/
    │       ├── app_services/
    │       │   ├── chat_controller.py
    │       │   ├── guardrails_controller.py
    │       │   └── rag_controller.py
    │       ├── auth_services/
    │       │   └── auth_controller.py
    │       ├── system_services/
    │       │   └── domain_controller.py
    │       └── ui_services/
    │           ├── component_controller.py
    │           ├── role_controller.py
    │           └── user_controller.py
    ├── data/
    │   ├── chroma/
    │   │   └── chroma.sqlite3
    │   └── documents/
    ├── docs/
    ├── dtos/
    │   ├── role_dto.py
    │   ├── app_data/
    │   │   ├── chat_dto.py
    │   │   ├── guardrails_dto.py
    │   │   └── rag_dto.py
    │   ├── auth_data/
    │   │   ├── auth_data.py
    │   │   └── otp_data.py
    │   ├── system_data/
    │   │   └── domain_dto.py
    │   └── ui_data/
    │       ├── component_dto.py
    │       └── user_dto.py
    ├── instance/
    │   └── app.db
    ├── migrations/
    │   └── init_db.py
    ├── models/
    │   ├── __init__.py
    │   ├── auth_models/
    │   │   ├── mapping_entities.py
    │   │   ├── role_entity.py
    │   │   └── user_entity.py
    │   ├── components/
    │   │   ├── agentic_models/
    │   │   │   ├── chat_entity.py
    │   │   │   └── document_entity.py
    │   │   └── guardrails_models/
    │   │       ├── gr_config_entity.py
    │   │       └── gr_log_entity.py
    │   └── system_models/
    │       ├── managemnt_models.py
    │       └── template_models/
    │           ├── mapping_entities.py
    │           └── template_entity.py
    ├── services/
    │   ├── __init__.py
    │   ├── agentic_services/
    │   │   ├── chat_service.py
    │   │   └── rag_service.py
    │   ├── auth_services/
    │   │   ├── auth_service.py
    │   │   ├── email_service.py
    │   │   └── otp_store.py
    │   ├── guardrails_services/
    │   │   └── guardrails_service.py
    │   ├── system_services/
    │   │   ├── domain_service.py
    │   │   └── user_service.py
    │   └── ui_services/
    │       └── component_service.py
    └── utils/
        ├── api_utils.py
        └── marshmallow_utils.py

================================================
File: README.md
================================================
# Enterprise Flask + Angular Microservice Backend

A headless Flask-based microservice with JWT authentication, LangChain Agentic RAG, LangGraph tool calling, and guardrails middleware.

## Features

- **User Management**: JWT-based authentication with role-based access control (User, Admin)
- **LangChain Agentic RAG**: Document upload and chat with Google Gemini + Chroma vector database
- **LangGraph Tool Calling**: AI chat with web search, API calls, and calculator tools
- **Guardrails Middleware**: Content moderation with PII detection, profanity filter, and custom rules
- **Component Management**: Dynamic component access control per role

## Tech Stack

- **Framework**: Flask 3.0 with flask-smorest (OpenAPI/Swagger)
- **Database**: SQLAlchemy with SQLite
- **Authentication**: JWT (Flask-JWT-Extended)
- **AI/ML**: LangChain, LangGraph, Google Gemini 2.0 Flash
- **Vector Storage**: Chroma + FAISS embeddings

## Project Structure

```
backend/
├── app.py                  # Main Flask application
├── config.py               # Configuration
├── models.py               # Database models
├── requirements.txt        # Python dependencies
├── .env.example           # Environment variables template
├── services/              # Business logic layer
│   ├── auth_service.py
│   ├── user_service.py
│   ├── component_service.py
│   ├── rag_service.py
│   ├── chat_service.py
│   └── guardrails_service.py
└── controllers/           # API endpoints
    ├── auth_controller.py
    ├── user_controller.py
    ├── rag_controller.py
    ├── chat_controller.py
    ├── component_controller.py
    └── guardrails_controller.py
```

## Setup Instructions

### 1. Create Virtual Environment (Recommended)

```bash
python -m venv venv

# Windows
venv\Scripts\activate

# Linux/Mac
source venv/bin/activate
```

### 2. Install Dependencies

```bash
pip install -r requirements.txt
```

### 3. Configure Environment Variables

Copy `.env.example` to `.env` and update:

```bash
cp .env.example .env
```

Edit `.env`:
```env
GOOGLE_API_KEY=your-actual-google-gemini-api-key
SECRET_KEY=your-random-secret-key
JWT_SECRET_KEY=your-random-jwt-secret
```

### 4. Run the Application

```bash
python app.py
```

The server will start at `http://localhost:5000`

### 5. Access API Documentation

Visit `http://localhost:5000/swagger-ui` for interactive API documentation.

## Default Credentials

- **Email**: admin@example.com
- **Password**: Admin@123
- **Role**: admin

⚠️ **IMPORTANT**: Change these credentials immediately after first login!

## API Endpoints

### Authentication
- `POST /api/auth/signup` - Register new user
- `POST /api/auth/login` - Login and get JWT token
- `GET /api/auth/me` - Get current user info

### User Management (Admin Only)
- `GET /api/users` - List all users
- `POST /api/users` - Create new user
- `GET /api/users/{id}` - Get user by ID
- `PUT /api/users/{id}/role` - Update user role
- `DELETE /api/users/{id}` - Delete user

### RAG (Document Chat)
- `POST /api/rag/upload` - Upload document
- `POST /api/rag/chat` - Chat with documents
- `GET /api/rag/documents` - List documents
- `DELETE /api/rag/documents/{id}` - Delete document

### Tool Calling Chat
- `POST /api/chat/tool-calling` - Chat with tools
- `GET /api/chat/history` - Get chat history
- `DELETE /api/chat/history` - Clear chat history

### Component Management
- `GET /api/components` - List available components
- `GET /api/components/user` - Get user's components
- `POST /api/components/assign` - Assign component to role (Admin)
- `GET /api/components/role/{role}` - Get role's components (Admin)

### Guardrails
- `GET /api/guardrails/config` - Get guardrails config
- `POST /api/guardrails/config` - Create guardrail rule (Admin)
- `PUT /api/guardrails/config/{id}` - Update guardrail (Admin)
- `DELETE /api/guardrails/config/{id}` - Delete guardrail (Admin)
- `GET /api/guardrails/logs` - Get detection logs (Admin)

## Usage Examples

### Login and Get Token

```bash
curl -X POST http://localhost:5000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@example.com","password":"Admin@123"}'
```

### Upload Document

```bash
curl -X POST http://localhost:5000/api/rag/upload \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -F "file=@document.pdf"
```

### Chat with Documents

```bash
curl -X POST http://localhost:5000/api/rag/chat \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"query":"What is this document about?","use_internet":false}'
```

### Tool Calling Chat

```bash
curl -X POST http://localhost:5000/api/chat/tool-calling \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"message":"Search the web for latest AI news"}'
```

## Environment Variables

| Variable | Description | Default |
|----------|-------------|---------|
| `GOOGLE_API_KEY` | Google Gemini API key | Required |
| `SECRET_KEY` | Flask secret key | Change in production |
| `JWT_SECRET_KEY` | JWT signing key | Change in production |
| `DATABASE_URI` | Database connection string | sqlite:///app.db |
| `GUARDRAILS_ENABLED` | Enable/disable guardrails | True |
| `CHROMA_DB_PATH` | Chroma vector DB path | ./data/chroma |
| `DOCUMENTS_PATH` | Uploaded documents path | ./data/documents |

## Security Notes

1. **Change default admin credentials** immediately
2. **Use strong SECRET_KEY and JWT_SECRET_KEY** in production
3. **Enable HTTPS** in production deployment
4. **Configure CORS** properly for your frontend domain
5. **Set appropriate file size limits** for uploads
6. **Keep API keys secure** and never commit to version control

## Troubleshooting

### Import Errors
Make sure virtual environment is activated and dependencies are installed.

### Database Errors
Delete `app.db` and restart to recreate database.

### API Key Errors
Verify `GOOGLE_API_KEY` is set correctly in `.env` file.

### Chroma/FAISS Errors
Ensure sufficient disk space for vector databases.

## Development

To run in development mode with auto-reload:

```bash
export FLASK_ENV=development
export FLASK_DEBUG=True
python app.py
```

## License

Enterprise-grade application for internal use.



================================================
File: app.py
================================================
from flask import Flask
from flask_smorest import Api
from flask_jwt_extended import JWTManager
from flask_cors import CORS
from dotenv import load_dotenv
from configs.app_config import Config
from models import db

from controllers import controllers_registers

def create_app(app_name=str, init_db:bool =True):
    """Application factory"""
    app = Flask(app_name)
    app.config.from_object(Config)
    
    # Flask-Smorest Config
    app.config["API_TITLE"] = "Enterprise API"
    app.config["API_VERSION"] = "v1"
    app.config["OPENAPI_VERSION"] = "3.0.2"
    app.config["OPENAPI_URL_PREFIX"] = "/"
    app.config["OPENAPI_SWAGGER_UI_PATH"] = "/docs"
    app.config["OPENAPI_SWAGGER_UI_URL"] = "https://cdn.jsdelivr.net/npm/swagger-ui-dist/"
    
    # Initialize config
    Config.init_app(app)
    
    # Initialize extensions
    db.init_app(app)
    jwt = JWTManager(app)
    CORS(app, origins=Config.CORS_ORIGINS, max_age=25, vary_header=True, supports_credentials=True, methods=['GET','POST','PUT','DELETE','OPTIONS'])
    
    # Initialize API
    api = Api(app)
    
    # Register all controller blueprints
    controllers_registers(api)
    
    # Initialize database and run migrations
    if init_db:
        from migrations.init_db import init_db
        init_db(app)
    
    @app.route('/health')
    def health():
        """Health check"""
        return {'status': 'healthy'}
    
    return app

if __name__ == '__main__':
    app = create_app(app_name="ONeApp", init_db=True)
    app.run(debug=True, host='0.0.0.0', port=5000)



================================================
File: requirements.txt
================================================
# Flask Framework
Flask
flask-cors

# Database
SQLAlchemy
Flask-SQLAlchemy
duckdb
sqlalchemy-duckdb

# Authentication
Flask-JWT-Extended
bcrypt

# LangChain & AI
langchain
langgraph
langchain-openai
langchain-community


# Vector Stores & Embeddings
chromadb
faiss-cpu
# sentence-transformers==2.3.1

# Document Processing
pypdf
python-docx
python-multipart

# Utilities
python-dotenv
marshmallow
requests
pydantic

# Web Search (Optional)
duckduckgo-search

# Development
watchdog
flask-smorest
marshmallow



================================================
File: configs/app_config.py
================================================
import os
from datetime import timedelta
from dotenv import load_dotenv

# Load environment variables
load_dotenv()


class Config:
    """Application configuration"""
    
    # Flask
    DEBUG = os.getenv('FLASK_DEBUG', 'True') == 'True'

    #JWT
    SECRET_KEY = os.getenv('SECRET_KEY', '')
    JWT_SECRET_KEY=os.getenv('JWT_SECRET_KEY', '')
    JWT_TOKEN_LOCATION=["headers","cookies"]
    JWT_ACCESS_TOKEN_EXPIRES=timedelta(hours=0,minutes=20)

    #Database
    SQLALCHEMY_DATABASE_URI= os.getenv('DATABASE_URI', '')
    SQLALCHEMY_TRACK_MODIFICATIONS=False 
    
    from sqlalchemy.pool import NullPool
    SQLALCHEMY_ENGINE_OPTIONS = {
        'poolclass': NullPool,
        'connect_args': {
            'config': {
                'allow_unsigned_extensions': 'true'
            }
        }
    }


    # API Configuration
    API_TITLE = 'Enterprise Flask Microservice'
    API_VERSION = 'v1'
    OPENAPI_VERSION = '3.0.2'
    OPENAPI_URL_PREFIX = '/'
    OPENAPI_SWAGGER_UI_PATH = '/swagger-ui'
    OPENAPI_SWAGGER_UI_URL = 'https://cdn.jsdelivr.net/npm/swagger-ui-dist/'
    
    # CORS
    CORS_ORIGINS = ['http://localhost:4200', 'http://127.0.0.1:4200']
    
    # OpenAI
    OPENAI_API_KEY = os.getenv('OPENAI_API_KEY', '')
    OPENAI_MODEL = 'gpt-4o'
    OPENAI_BASE_URL = os.getenv('OPENAI_BASE_URL', '')
    
    # Google Gemini (Deprecated)
    GOOGLE_API_KEY = os.getenv('GOOGLE_API_KEY', '')
    GEMINI_MODEL = 'gemini-2.0-flash-exp'
    
    # Brave Search
    BRAVE_API_KEY = os.getenv('BRAVE_API_KEY', '')
    
    # Vector Database
    CHROMA_DB_PATH = os.getenv('CHROMA_DB_PATH', './data/chroma')
    DOCUMENTS_PATH = os.getenv('DOCUMENTS_PATH', './data/documents')
    
    # Guardrails
    GUARDRAILS_ENABLED = os.getenv('GUARDRAILS_ENABLED', 'True') == 'True'
    
    # File Upload
    MAX_CONTENT_LENGTH = 16 * 1024 * 1024  # 16MB max file size
    ALLOWED_EXTENSIONS = {'pdf', 'txt', 'docx', 'doc', 'md'}

    # SMTP Configuration
    SMTP_SERVER = os.getenv('SMTP_SERVER', 'smtp.gmail.com')
    SMTP_PORT = int(os.getenv('SMTP_PORT', 587))
    SMTP_USERNAME = os.getenv('SMTP_USERNAME', '')
    SMTP_PASSWORD = os.getenv('SMTP_PASSWORD', '')
    SMTP_SENDER_EMAIL = os.getenv('SMTP_SENDER_EMAIL', '')
    
    @staticmethod
    def init_app(app):
        """Initialize application with config"""
        # Create necessary directories
        os.makedirs(Config.CHROMA_DB_PATH, exist_ok=True)
        os.makedirs(Config.DOCUMENTS_PATH, exist_ok=True)



================================================
File: controllers/__init__.py
================================================
# Controllers package

from flask_smorest import Api

from controllers.frontend.ui_controller import api as UIController
from controllers.authentication.auth_controller import api as AuthController
from controllers.app_controllers.agentic.agentic_controller import api as AgenticController 
from controllers.app_controllers.guardrails.guardrails_controller import api as GuardrailsController


def controllers_registers(api:Api):
    api.register_blueprint(AuthController)
    api.register_blueprint(UIController)
    api.register_blueprint(AgenticController)
    api.register_blueprint(GuardrailsController)






================================================
File: controllers/app_controllers/agentic/agentic_controller.py
================================================
"""
Agentic Domain Controller - RAG and Chat functionality
Consolidated from rag_controller and chat_controller
"""
import os
import uuid
from flask import request
from flask_smorest import Blueprint
from flask_jwt_extended import jwt_required, get_jwt_identity
from marshmallow import ValidationError, Schema, fields
from werkzeug.utils import secure_filename

from services.agentic_services.rag_service import RAGService
from services.agentic_services.chat_service import ChatService
from services.guardrails_services.guardrails_service import GuardrailsService
from dtos.app_data.rag_dto import (
    DocumentSchema, RagChatRequestSchema, RagChatResponseSchema
)
from dtos.app_data.chat_dto import (
    ToolChatRequestSchema, ToolChatResponseSchema, ChatHistorySchema
)
from configs.app_config import Config

api = Blueprint(
    name='AgenticController', 
    import_name='AgenticController', 
    url_prefix='/api/ai', 
    description='Agentic domain operations (RAG & Chat)')



class UploadSchema(Schema):
    file = fields.Raw(type='string', format='binary', required=True, metadata={'description': 'Document file'})


class AgenticController:
    """Agentic Controller - Handles RAG and Chat endpoints"""
    
    # ============================================================================
    # RAG OPERATIONS
    # ============================================================================
    
    @staticmethod
    @api.route('/rag/upload', methods=['POST'])
    @api.arguments(UploadSchema, location='files')
    @api.response(201, DocumentSchema)
    @jwt_required()
    def api_post_rag_upload(files):
        """Upload document for RAG"""
        try:
            user_id = get_jwt_identity()
            file = files['file']
            
            rag_service = RAGService()
            document = rag_service.upload_document(file, user_id)
            
            return document
        except ValueError as e:
            api.abort(400, message=str(e))
        except Exception as e:
            api.abort(500, message=f'Upload failed: {str(e)}')
    
    @staticmethod
    @api.route('/rag/chat', methods=['POST'])
    @api.arguments(RagChatRequestSchema)
    @api.response(200, RagChatResponseSchema)
    @jwt_required()
    def api_post_rag_chat(data):
        """Chat with documents using RAG"""
        try:
            user_id = get_jwt_identity()
            
            guardrails_result = GuardrailsService.check_content(
                data['query'],
                user_id,
                'input'
            )
            
            if not guardrails_result['passed']:
                agentic.abort(400, message='Content violates guardrails', violations=guardrails_result['violations'])
            
            rag_service = RAGService()
            response = rag_service.chat_with_documents(
                query=data['query'],
                user_id=user_id,
                use_internet=data.get('use_internet', False)
            )
            
            output_check = GuardrailsService.check_content(
                response['answer'],
                user_id,
                'output'
            )
            
            if not output_check['passed']:
                response['answer'] = output_check['cleaned_content']
            
            return response
        except ValidationError as err:
            agentic.abort(400, message=str(err.messages))
        except ValueError as e:
            api.abort(400, message=str(e))
        except Exception as e:
            api.abort(500, message=f'Chat failed: {str(e)}')
    
    @staticmethod
    @api.route('/rag/documents', methods=['GET'])
    @api.response(200, DocumentSchema(many=True))
    @jwt_required()
    def api_get_rag_documents():
        """Get user's documents"""
        try:
            user_id = get_jwt_identity()
            rag_service = RAGService()
            documents = rag_service.get_user_documents(user_id)
            return documents
        except Exception as e:
            api.abort(500, message=str(e))
    
    @staticmethod
    @api.route('/rag/documents/<int:document_id>', methods=['DELETE'])
    @api.response(200, description="Document deleted")
    @jwt_required()
    def api_delete_rag_document(document_id):
        """Delete document"""
        try:
            user_id = get_jwt_identity()
            rag_service = RAGService()
            result = rag_service.delete_document(document_id, user_id)
            return result
        except ValueError as e:
            agentic.abort(404, message=str(e))
        except Exception as e:
            agentic.abort(500, message=str(e))
    
    # ============================================================================
    # CHAT OPERATIONS
    # ============================================================================
    
    @staticmethod
    @api.route('/chat/tool-calling', methods=['POST'])
    @api.response(200, ToolChatResponseSchema)
    @jwt_required()
    def api_post_chat_tool_calling():
        """Chat with tool calling and optional image support"""
        try:
            user_id = get_jwt_identity()
            images = []
            message = None
            
            if request.files or request.form:
                message = request.form.get('message')
                if not message:
                    agentic.abort(400, message='Message is required')
                
                for key in request.files:
                    file = request.files[key]
                    if file and file.filename:
                        filename = secure_filename(file.filename)
                        ext = filename.rsplit('.', 1)[-1].lower() if '.' in filename else ''
                        
                        allowed_image_types = {'jpg', 'jpeg', 'png', 'gif', 'webp'}
                        if ext not in allowed_image_types:
                            agentic.abort(400, message=f'Invalid image type. Allowed: {allowed_image_types}')
                        
                        temp_dir = os.path.join(Config.DOCUMENTS_PATH, 'temp_images')
                        os.makedirs(temp_dir, exist_ok=True)
                        
                        temp_filename = f"{uuid.uuid4()}_{filename}"
                        temp_path = os.path.join(temp_dir, temp_filename)
                        file.save(temp_path)
                        images.append(temp_path)
            else:
                json_data = request.get_json()
                if not json_data:
                     agentic.abort(400, message='No data provided')
                data = ToolChatRequestSchema().load(json_data)
                message = data['message']
            
            guardrails_result = GuardrailsService.check_content(
                message,
                user_id,
                'input'
            )
            
            if not guardrails_result['passed']:
                for img_path in images:
                    if os.path.exists(img_path):
                        os.remove(img_path)
                agentic.abort(400, message='Content violates guardrails', violations=guardrails_result['violations'])
            
            chat_service = ChatService()
            history = chat_service.get_chat_history(user_id, 'tool', limit=10)
            
            response = chat_service.chat_with_tools(
                message=message,
                user_id=user_id,
                chat_history=history,
                images=images if images else None
            )
            
            for img_path in images:
                if os.path.exists(img_path):
                    os.remove(img_path)
            
            output_check = GuardrailsService.check_content(
                response['answer'],
                user_id,
                'output'
            )
            
            if not output_check['passed']:
                response['answer'] = output_check['cleaned_content']
            
            return response
        except ValidationError as err:
            agentic.abort(400, message=str(err.messages))
        except ValueError as e:
            api.abort(400, message=str(e))
        except Exception as e:
            api.abort(500, message=f'Chat failed: {str(e)}')
    
    @staticmethod
    @api.route('/chat/history', methods=['GET'])
    @api.response(200, ChatHistorySchema(many=True))
    @jwt_required()
    def api_get_chat_history():
        """Get chat history"""
        try:
            user_id = get_jwt_identity()
            chat_service = ChatService()
            history = chat_service.get_chat_history(user_id, limit=50)
            return history
        except Exception as e:
            api.abort(500, message=str(e))
    
    @staticmethod
    @api.route('/chat/history', methods=['DELETE'])
    @api.response(200, description="History cleared")
    @jwt_required()
    def api_delete_chat_history():
        """Clear chat history"""
        try:
            user_id = get_jwt_identity()
            chat_service = ChatService()
            result = chat_service.clear_chat_history(user_id)
            return result
        except Exception as e:
            agentic.abort(500, message=str(e))



================================================
File: controllers/app_controllers/guardrails/guardrails_controller.py
================================================
"""
Guardrails Controller - Guardrail configuration and logging
"""
from flask_smorest import Blueprint
from flask_jwt_extended import jwt_required
from marshmallow import ValidationError

from services.guardrails_services.guardrails_service import GuardrailsService
from services.auth_services.auth_service import AuthService
from dtos.app_data.guardrails_dto import (
    GuardrailConfigSchema, UpdateGuardrailSchema, CreateGuardrailSchema, GuardrailLogSchema
)

# Create Blueprint
api = Blueprint(
    name='GuardrailsController', 
    import_name='GuardrailsController', 
    url_prefix='/api/guardrails', 
    description='Guardrails domain operations (RAG & Chat)')

class GuardrailsController:
    """Guardrails Controller - Manages guardrail configuration and logs"""
    
    @staticmethod
    @api.route('/config', methods=['GET'])
    @api.response(200, GuardrailConfigSchema(many=True))
    @jwt_required()
    def api_get_guardrail_config():
        """Get guardrails configuration"""
        try:
            config = GuardrailsService.get_guardrails_config()
            return config
        except Exception as e:
            api.abort(500, message=str(e))
    
    @staticmethod
    @api.route('/config', methods=['POST'])
    @api.arguments(CreateGuardrailSchema)
    @api.response(201, GuardrailConfigSchema)
    @jwt_required()
    def api_post_guardrail_config(data):
        """Create new guardrail rule (admin only)"""
        try:
            AuthService.verify_admin()
            rule = GuardrailsService.create_guardrail(**data)
            return rule
        except ValidationError as err:
            api.abort(400, message=str(err.messages))
        except ValueError as e:
            api.abort(400, message=str(e))
        except Exception as e:
            api.abort(500, message=str(e))
    
    @staticmethod
    @api.route('/config/<int:rule_id>', methods=['PUT'])
    @api.arguments(UpdateGuardrailSchema)
    @api.response(200, GuardrailConfigSchema)
    @jwt_required()
    def api_put_guardrail_config(data, rule_id):
        """Update guardrail configuration (admin only)"""
        try:
            AuthService.verify_admin()
            rule = GuardrailsService.update_guardrail(rule_id, **data)
            return rule
        except ValidationError as err:
            guardrails.abort(400, message=str(err.messages))
        except ValueError as e:
            api.abort(400, message=str(e))
        except Exception as e:
            api.abort(500, message=str(e))
    
    @staticmethod
    @api.route('/config/<int:rule_id>', methods=['DELETE'])
    @api.response(200, description="Rule deleted")
    @jwt_required()
    def api_delete_guardrail_config(rule_id):
        """Delete guardrail rule (admin only)"""
        try:
            AuthService.verify_admin()
            result = GuardrailsService.delete_guardrail(rule_id)
            return result
        except ValueError as e:
            api.abort(400, message=str(e))
        except Exception as e:
            api.abort(500, message=str(e))
    
    @staticmethod
    @api.route('/logs', methods=['GET'])
    @api.response(200, GuardrailLogSchema(many=True))
    @jwt_required()
    def api_get_guardrails_logs():
        """Get guardrails detection logs (admin only)"""
        try:
            AuthService.verify_admin()
            logs = GuardrailsService.get_guardrails_logs(limit=100)
            return logs
        except ValueError as e:
            api.abort(403, message=str(e))
        except Exception as e:
            api.abort(500, message=str(e))



================================================
File: controllers/authentication/auth_controller.py
================================================
from flask import request, jsonify
from flask.views import MethodView
from flask_smorest import Blueprint, abort
from flask_jwt_extended import jwt_required

from services.auth_services.auth_service import AuthService
from dtos.auth_data.auth_data import (
    LoginSchema, SignupSchema, UserResponseSchema, CheckEmailSchema,
    AuthResponseSchema, CheckEmailResponseSchema, SignupConfigSchema,
    SwitchDomainSchema
)
from dtos.auth_data.otp_data import VerifyOtpSchema

# Create Blueprint
api = Blueprint(
    name='AuthController', 
    import_name='AuthController', 
    url_prefix='/api/auth', 
    description='Authentication operations')


class AuthController:
    """apientication Controller - Handles all apientication endpoints"""
    
    @staticmethod
    @api.post('/check-access')
    @api.arguments(CheckEmailSchema)
    @api.response(200, CheckEmailResponseSchema)
    def api_post_check_access(data):
        """Check if email exists and get role"""
        try:
            result = AuthService.check_user_exists(data['email'])
            return result
        except Exception as e:
            abort(400, message=str(e))
    
    @staticmethod
    @api.route('/signup', methods=['POST'])
    @api.arguments(SignupSchema)
    @api.response(201, AuthResponseSchema)
    def api_post_signup(data):
        """User registration"""
        try:
            from models import SystemConfig, UserDetailsModel
            config = SystemConfig.query.get('signup_enabled')
            if config and config.value.lower() != 'true':
                if UserDetailsModel.query.count() > 0:
                    abort(403, message="Public registration is currently disabled. Please contact an administrator.")

            result = AuthService.register_user(
                email=data['email'],
                password=data['password'],
                role=data.get('role', 'user'),
                full_name=data.get('full_name')
            )
            return result
        except Exception as e:
            abort(400, message=str(e))
    
    @staticmethod
    @api.route('/login', methods=['POST'])
    @api.arguments(LoginSchema)
    @api.response(200, AuthResponseSchema)
    def api_post_login(data):
        """User login"""
        try:
            result = AuthService.login_user(
                email=data['email'],
                password=data['password'],
                role=data.get('role')
            )
            return result
        except Exception as e:
            abort(401, message=str(e))
    
    @staticmethod
    @api.route('/verify-otp', methods=['POST'])
    @api.arguments(VerifyOtpSchema)
    @api.response(200, AuthResponseSchema)
    def api_post_verify_otp(data):
        """Verify OTP for 2FA"""
        try:
            result = AuthService.verify_otp(
                email=data['email'],
                otp=data['otp'],
                role=data.get('role')
            )
            return result
        except Exception as e:
            abort(401, message=str(e))
            
    @staticmethod
    @api.route('/switch-domain', methods=['POST'])
    @api.arguments(SwitchDomainSchema)
    @api.response(200, AuthResponseSchema)
    @jwt_required()
    def api_post_switch_domain(data):
        """Switch active domain"""
        try:
            result = AuthService.switch_domain(data['domain_id'])
            return result
        except Exception as e:
            abort(401, message=str(e))
    
    @staticmethod
    @api.route('/me', methods=['GET'])
    @api.response(200, UserResponseSchema)
    @jwt_required()
    def api_get_me():
        """Get current user"""
        try:
            user = AuthService.get_current_user()
            return user
        except Exception as e:
            abort(500, message=str(e))
    
    @staticmethod
    @api.route('/config/signup', methods=['GET'])
    @api.response(200, SignupConfigSchema)
    def api_get_signup_config():
        """Get signup configuration"""
        try:
            from models import SystemConfig
            config = SystemConfig.query.get('signup_enabled')
            return {'enabled': config.value.lower() == 'true' if config else True}
        except Exception as e:
            abort(500, message=str(e))
    
    @staticmethod
    @api.route('/config/signup', methods=['POST'])
    @api.arguments(SignupConfigSchema)
    @api.response(200, SignupConfigSchema)
    @jwt_required()
    def api_post_signup_config(data):
        """Update signup configuration (Admin only)"""
        try:
            user = AuthService.get_current_user()
            if not user.is_admin():
                abort(403, message="Admin access required")
            
            enabled = data.get('enabled', True)
            
            from models import SystemConfig, db
            config = SystemConfig.query.get('signup_enabled')
            if not config:
                config = SystemConfig(key='signup_enabled', description='Enable or disable public user registration')
                db.session.add(config)
            
            config.value = str(enabled).lower()
            db.session.commit()
            
            return {'enabled': config.value == 'true', 'message': 'Configuration updated'}
        except Exception as e:
            abort(500, message=str(e))



================================================
File: controllers/frontend/ui_controller.py
================================================
"""
Frontend UI Controller - User, Role, Component, Domain Management
Consolidated from user_controller, role_controller, component_controller, domain_controller
"""
from flask import request, jsonify
from flask_smorest import Blueprint
from flask_jwt_extended import jwt_required, get_jwt
from marshmallow import ValidationError

from models import db, RoleModel
from services.system_services.user_service import UserService
from services.auth_services.auth_service import AuthService
from services.ui_services.component_service import ComponentService
from services.system_services.domain_service import DomainService

from dtos.ui_data.user_dto import UserSchema, CreateUserSchema, UpdateUserSchema
from dtos.role_dto import RoleSchema, RoleCreateSchema, RoleUpdateSchema, AssignRolesSchema
from dtos.ui_data.component_dto import (
    ComponentsListSchema, AssignComponentSchema, ComponentAccessSchema,
    ComponentListResponseSchema, NavigationResponseSchema
)
from dtos.system_data.domain_dto import DomainSchema, CreateDomainSchema, UpdateDomainSchema

# Create Blueprint
api = Blueprint(
    name='UIController', 
    import_name='UIController', 
    url_prefix='/api/ui', 
    description='Frontend management operations')


class UIController:
    """Frontend UI Controller - Manages Users, Roles, Components, and Domains"""
    
    # ============================================================================
    # USER MANAGEMENT
    # ============================================================================
    
    @staticmethod
    @api.route('/users', methods=['GET'])
    @api.response(200, UserSchema(many=True))
    @jwt_required()
    def api_get_users():
        """List all users (admin only)"""
        try:
            AuthService.verify_admin()
            users = UserService.get_all_users()
            return users
        except ValueError as e:
            ui.abort(403, message=str(e))
        except Exception as e:
            ui.abort(500, message=str(e))
    
    @staticmethod
    @api.route('/users', methods=['POST'])
    @api.arguments(CreateUserSchema)
    @api.response(201, UserSchema)
    @jwt_required()
    def api_post_user(data):
        """Create new user (admin only)"""
        try:
            AuthService.verify_admin()
            
            roles_to_assign = data.get('roles') or [data.get('role', 'user')]
            
            user = AuthService.create_user(
                email=data['email'],
                password=data['password'],
                roles=roles_to_assign,
                full_name=data.get('full_name'),
                file_upload_enabled=data.get('file_upload_enabled', False),
                two_factor_auth_enabled=data.get('two_factor_auth_enabled', False)
            )
            return user
        except ValidationError as err:
            ui.abort(400, message=str(err.messages))
        except ValueError as e:
            ui.abort(400, message=str(e))
        except Exception as e:
            ui.abort(500, message=str(e))
    
    @staticmethod
    @api.route('/users/<int:user_id>', methods=['GET'])
    @api.response(200, UserSchema)
    @jwt_required()
    def api_get_user(user_id):
        """Get user by ID (admin only)"""
        try:
            AuthService.verify_admin()
            user = UserService.get_user_by_id(user_id)
            return user
        except ValueError as e:
            ui.abort(404, message=str(e))
        except Exception as e:
            ui.abort(500, message=str(e))
    
    @staticmethod
    @api.route('/users/<int:user_id>', methods=['PUT'])
    @api.arguments(UpdateUserSchema)
    @api.response(200, UserSchema)
    @jwt_required()
    def api_put_user(data, user_id):
        """Update user details (admin only)"""
        try:
            AuthService.verify_admin()
            user = UserService.update_user(user_id, data)
            return user
        except ValidationError as err:
            ui.abort(400, message=str(err.messages))
        except ValueError as e:
            ui.abort(400, message=str(e))
        except Exception as e:
            ui.abort(500, message=str(e))
    
    @staticmethod
    @api.route('/users/<int:user_id>', methods=['DELETE'])
    @api.response(200, description="User deleted")
    @jwt_required()
    def api_delete_user(user_id):
        """Delete user (admin only)"""
        try:
            AuthService.verify_admin()
            result = UserService.delete_user(user_id)
            return result
        except ValueError as e:
            ui.abort(400, message=str(e))
        except Exception as e:
            ui.abort(500, message=str(e))
    
    # ============================================================================
    # ROLE MANAGEMENT
    # ============================================================================
    
    @staticmethod
    @api.route('/roles', methods=['GET'])
    @api.response(200, RoleSchema(many=True))
    @jwt_required()
    def api_get_roles():
        """Get all roles"""
        try:
            roles = RoleModel.query.all()
            return roles
        except Exception as e:
            ui.abort(500, message=str(e))
    
    @staticmethod
    @api.route('/roles', methods=['POST'])
    @api.arguments(RoleCreateSchema)
    @api.response(201, RoleSchema)
    @jwt_required()
    def api_post_role(data):
        """Create a new role (Admin only)"""
        try:
            user = AuthService.get_current_user()
            if not user.is_admin():
                ui.abort(403, message="Admin access required")
            
            if RoleModel.query.filter_by(role_name=data['name']).first():
                ui.abort(400, message=f"Role '{data['name']}' already exists")
            
            role = RoleModel(
                role_name=data['name'],
                description=data.get('description')
            )
            db.session.add(role)
            db.session.commit()
            
            return role
        except ValidationError as err:
            ui.abort(400, message=str(err.messages))
        except ValueError as e:
            ui.abort(400, message=str(e))
        except Exception as e:
            ui.abort(500, message=str(e))
    
    @staticmethod
    @api.route('/roles/<int:role_id>', methods=['GET'])
    @api.response(200, RoleSchema)
    @jwt_required()
    def api_get_role(role_id):
        """Get a specific role"""
        try:
            role = RoleModel.query.get(role_id)
            if not role:
                ui.abort(404, message="Role not found")
            return role
        except Exception as e:
            ui.abort(500, message=str(e))
    
    @staticmethod
    @api.route('/roles/<int:role_id>', methods=['PUT'])
    @api.arguments(RoleUpdateSchema)
    @api.response(200, RoleSchema)
    @jwt_required()
    def api_put_role(data, role_id):
        """Update a role (Admin only)"""
        try:
            user = AuthService.get_current_user()
            if not user.is_admin():
                ui.abort(403, message="Admin access required")
            
            role = RoleModel.query.get(role_id)
            if not role:
                ui.abort(404, message="Role not found")
            
            if role.role_name in ['admin', 'user']:
                ui.abort(400, message="Cannot modify default system roles")
            
            if 'name' in data:
                existing = RoleModel.query.filter_by(role_name=data['name']).first()
                if existing and existing.role_id != role_id:
                    ui.abort(400, message=f"Role '{data['name']}' already exists")
                role.role_name = data['name']
            
            if 'description' in data:
                role.description = data['description']
            
            db.session.commit()
            return role
        except ValidationError as err:
            ui.abort(400, message=str(err.messages))
        except ValueError as e:
            ui.abort(400, message=str(e))
        except Exception as e:
            ui.abort(500, message=str(e))
    
    @staticmethod
    @api.route('/roles/<int:role_id>', methods=['DELETE'])
    @api.response(200, description="Role deleted")
    @jwt_required()
    def api_delete_role(role_id):
        """Delete a role (Admin only)"""
        try:
            user = AuthService.get_current_user()
            if not user.is_admin():
                ui.abort(403, message="Admin access required")
            
            role = RoleModel.query.get(role_id)
            if not role:
                ui.abort(404, message="Role not found")
            
            if role.role_name in ['admin', 'user']:
                ui.abort(400, message="Cannot delete default system roles")
            
            db.session.delete(role)
            db.session.commit()
            
            return {'message': f"Role '{role.role_name}' deleted successfully"}
        except ValueError as e:
            ui.abort(400, message=str(e))
        except Exception as e:
            ui.abort(500, message=str(e))
    
    @staticmethod
    @api.route('/roles/assign', methods=['POST'])
    @api.arguments(AssignRolesSchema)
    @api.response(200, description="Roles assigned")
    @jwt_required()
    def api_post_assign_roles(data):
        """Assign roles to a user (Admin only)"""
        try:
            user = AuthService.get_current_user()
            if not user.is_admin():
                ui.abort(403, message="Admin access required")
            
            AuthService.assign_roles(
                user_id=data['user_id'],
                role_names=data['role_names']
            )
            
            return {'message': 'Roles assigned successfully'}
        except ValidationError as err:
            ui.abort(400, message=str(err.messages))
        except ValueError as e:
            ui.abort(400, message=str(e))
        except Exception as e:
            ui.abort(500, message=str(e))
    
    # ============================================================================
    # COMPONENT MANAGEMENT
    # ============================================================================
    
    @staticmethod
    @api.route('/components', methods=['GET'])
    @jwt_required()
    def api_get_components():
        """Get available components"""
        try:
            components = ComponentService.get_available_components()
            return components
        except Exception as e:
            ui.abort(500, message=str(e))
    
    @staticmethod
    @api.route('/components/user', methods=['GET'])
    @api.response(200, ComponentListResponseSchema)
    @jwt_required()
    def api_get_user_components():
        """Get current user's accessible components"""
        try:
            components = ComponentService.get_user_components()
            return {'components': components}
        except Exception as e:
            ui.abort(500, message=str(e))
    
    @staticmethod
    @api.route('/components/assign', methods=['POST'])
    @api.arguments(AssignComponentSchema)
    @api.response(200, ComponentAccessSchema)
    @jwt_required()
    def api_post_assign_component(data):
        """Assign component to role (admin only)"""
        try:
            AuthService.verify_admin()
            result = ComponentService.assign_component_to_role(
                role_name=data['role'],
                component_name=data['component_name'],
                has_access=data.get('has_access', True)
            )
            return result
        except ValidationError as err:
            ui.abort(400, message=str(err.messages))
        except ValueError as e:
            ui.abort(400, message=str(e))
        except Exception as e:
            ui.abort(500, message=str(e))
    
    @staticmethod
    @api.route('/components/role/<string:role>', methods=['GET'])
    @api.response(200, ComponentListResponseSchema)
    @jwt_required()
    def api_get_role_components(role):
        """Get components for a specific role (admin only)"""
        try:
            AuthService.verify_admin()
            components = ComponentService.get_role_components(role)
            return {'components': components}
        except ValueError as e:
            ui.abort(400, message=str(e))
        except Exception as e:
            ui.abort(500, message=str(e))
    
    @staticmethod
    @api.route('/components/navigation', methods=['GET'])
    @jwt_required()
    def api_get_navigation():
        """Get navigation menu for current user based on ACTIVE ROLE and DOMAIN from JWT"""
        try:
            claims = get_jwt()
            active_role = claims.get('role')
            domain_id = claims.get('domain_id')

            if not active_role:
                ui.abort(400, message='No active role found in JWT')

            nav_items = ComponentService.get_navigation(active_role, domain_id)
            return {'navigation': nav_items}

        except Exception as e:
            ui.abort(500, message=str(e))
    
    # ============================================================================
    # DOMAIN MANAGEMENT
    # ============================================================================
    
    @staticmethod
    @api.route('/domains', methods=['GET'])
    @api.response(200, DomainSchema(many=True))
    @jwt_required()
    def api_get_domains():
        """List all domains (Platform Admin only)"""
        try:
            AuthService.verify_platform_admin()
            domains = DomainService.get_all_domains()
            return domains
        except ValueError as e:
            ui.abort(403, message=str(e))
        except Exception as e:
            ui.abort(500, message=str(e))
    
    @staticmethod
    @api.route('/domains', methods=['POST'])
    @api.arguments(CreateDomainSchema)
    @api.response(201, DomainSchema)
    @jwt_required()
    def api_post_domain(data):
        """Create new domain (Platform Admin only)"""
        try:
            AuthService.verify_platform_admin()
            domain = DomainService.create_domain(**data)
            return domain
        except ValidationError as err:
            ui.abort(400, message=str(err.messages))
        except ValueError as e:
            ui.abort(400, message=str(e))
        except Exception as e:
            ui.abort(500, message=str(e))
    
    @staticmethod
    @api.route('/domains/<int:domain_id>', methods=['GET'])
    @api.response(200, DomainSchema)
    @jwt_required()
    def api_get_domain(domain_id):
        """Get domain by ID (Platform Admin only)"""
        try:
            AuthService.verify_platform_admin()
            domain = DomainService.get_domain_by_id(domain_id)
            return domain
        except ValueError as e:
            ui.abort(404, message=str(e))
        except Exception as e:
            ui.abort(500, message=str(e))
    
    @staticmethod
    @api.route('/domains/<int:domain_id>', methods=['PUT'])
    @api.arguments(UpdateDomainSchema)
    @api.response(200, DomainSchema)
    @jwt_required()
    def api_put_domain(data, domain_id):
        """Update domain (Platform Admin only)"""
        try:
            AuthService.verify_platform_admin()
            domain = DomainService.update_domain(domain_id, data)
            return domain
        except ValidationError as err:
            ui.abort(400, message=str(err.messages))
        except ValueError as e:
            ui.abort(400, message=str(e))
        except Exception as e:
            ui.abort(500, message=str(e))
    
    @staticmethod
    @api.route('/domains/<int:domain_id>', methods=['DELETE'])
    @api.response(200, description="Domain deleted")
    @jwt_required()
    def api_delete_domain(domain_id):
        """Delete domain (Platform Admin only)"""
        try:
            AuthService.verify_platform_admin()
            result = DomainService.delete_domain(domain_id)
            return result
        except ValueError as e:
            ui.abort(400, message=str(e))
        except Exception as e:
            ui.abort(500, message=str(e))
    
    # ============================================================================
    # USER-DOMAIN ASSIGNMENT (Platform Admin)
    # ============================================================================
    
    @staticmethod
    @api.route('/domains/<int:domain_id>/users', methods=['GET'])
    @api.response(200, description="List of users in domain")
    @jwt_required()
    def api_get_domain_users(domain_id):
        """Get all users assigned to a domain (Platform Admin only)"""
        try:
            AuthService.verify_platform_admin()
            users = UserService.get_users_by_domain(domain_id)
            return {'users': users}
        except ValueError as e:
            ui.abort(403, message=str(e))
        except Exception as e:
            ui.abort(500, message=str(e))
    
    @staticmethod
    @api.route('/domains/<int:domain_id>/users', methods=['POST'])
    @api.response(200, description="User assigned to domain")
    @jwt_required()
    def api_assign_user_to_domain(domain_id):
        """Assign user to domain with role (Platform Admin only)"""
        try:
            AuthService.verify_platform_admin()
            data = request.get_json()
            
            user_id = data.get('user_id')
            role_name = data.get('role_name', 'user')
            
            if not user_id:
                ui.abort(400, message='user_id is required')
            
            result = UserService.assign_user_to_domain(user_id, domain_id, role_name)
            return result
        except ValueError as e:
            ui.abort(400, message=str(e))
        except Exception as e:
            ui.abort(500, message=str(e))
    
    @staticmethod
    @api.route('/domains/<int:domain_id>/users/<int:user_id>', methods=['DELETE'])
    @api.response(200, description="User removed from domain")
    @jwt_required()
    def api_remove_user_from_domain(domain_id, user_id):
        """Remove user from domain (Platform Admin only)"""
        try:
            AuthService.verify_platform_admin()
            result = UserService.remove_user_from_domain(user_id, domain_id)
            return result
        except ValueError as e:
            ui.abort(400, message=str(e))
        except Exception as e:
            ui.abort(500, message=str(e))
    
    # ============================================================================
    # SYSTEM LOGS (Platform Admin)
    # ============================================================================
    
    @staticmethod
    @api.route('/logs', methods=['GET'])
    @api.response(200, description="System logs")
    @jwt_required()
    def api_get_system_logs():
        """Get system logs (Platform Admin only)"""
        try:
            AuthService.verify_platform_admin()
            # TODO: Implement actual system logging
            # For now, return placeholder
            return {
                'logs': [],
                'message': 'System logs endpoint - to be implemented'
            }
        except ValueError as e:
            ui.abort(403, message=str(e))
        except Exception as e:
            ui.abort(500, message=str(e))



================================================
File: controllers/.scrap/app_services/chat_controller.py
================================================
import os
import uuid
from flask import request, jsonify
from flask.views import MethodView
from flask_smorest import Blueprint, abort
from flask_jwt_extended import jwt_required, get_jwt_identity
from marshmallow import ValidationError, Schema, fields
from werkzeug.utils import secure_filename
from werkzeug.datastructures import FileStorage

from services.agentic_services.chat_service import ChatService
from services.guardrails_services.guardrails_service import GuardrailsService
from dtos.app_data.chat_dto import (
    ToolChatRequestSchema, ToolChatResponseSchema, ChatHistorySchema
)
from config import Config

chat_blp = Blueprint('chat', 'chat', url_prefix='/chat', description='Chat operations with tool calling')

@chat_blp.route('/tool-calling')
class ToolChat(MethodView):
    @chat_blp.response(200, ToolChatResponseSchema)
    @jwt_required()
    def post(self):
        """Chat with tool calling and optional image support
        
        Accepts JSON: {"message": "..."}
        OR Multipart/Form-Data: message="...", file=@image.png
        """
        try:
            user_id = get_jwt_identity()
            
            # Check if request has files (multipart/form-data)
            images = []
            message = None
            
            # Manual parsing to support both JSON and Multipart
            if request.files or request.form:
                # Handle multipart form data
                message = request.form.get('message')
                if not message:
                    abort(400, message='Message is required')
                
                # Process uploaded images
                for key in request.files:
                    file = request.files[key]
                    if file and file.filename:
                        # Validate image type
                        filename = secure_filename(file.filename)
                        ext = filename.rsplit('.', 1)[-1].lower() if '.' in filename else ''
                        
                        allowed_image_types = {'jpg', 'jpeg', 'png', 'gif', 'webp'}
                        if ext not in allowed_image_types:
                            abort(400, message=f'Invalid image type. Allowed: {allowed_image_types}')
                        
                        # Save temporarily
                        temp_dir = os.path.join(Config.DOCUMENTS_PATH, 'temp_images')
                        os.makedirs(temp_dir, exist_ok=True)
                        
                        temp_filename = f"{uuid.uuid4()}_{filename}"
                        temp_path = os.path.join(temp_dir, temp_filename)
                        file.save(temp_path)
                        images.append(temp_path)
            else:
                # Handle JSON request
                # We use the schema to load/validate manually
                json_data = request.get_json()
                if not json_data:
                     abort(400, message='No data provided')
                data = ToolChatRequestSchema().load(json_data)
                message = data['message']
            
            # Check guardrails on input
            guardrails_result = GuardrailsService.check_content(
                message,
                user_id,
                'input'
            )
            
            if not guardrails_result['passed']:
                # Clean up temp images
                for img_path in images:
                    if os.path.exists(img_path):
                        os.remove(img_path)
                
                abort(400, message='Content violates guardrails', violations=guardrails_result['violations'])
            
            # Initialize chat service
            chat_service = ChatService()
            
            # Get recent chat history
            history = chat_service.get_chat_history(user_id, 'tool', limit=10)
            
            # Process chat with optional images
            response = chat_service.chat_with_tools(
                message=message,
                user_id=user_id,
                chat_history=history,
                images=images if images else None
            )
            
            # Clean up temp images
            for img_path in images:
                if os.path.exists(img_path):
                    os.remove(img_path)
            
            # Check guardrails on output
            output_check = GuardrailsService.check_content(
                response['answer'],
                user_id,
                'output'
            )
            
            if not output_check['passed']:
                response['answer'] = output_check['cleaned_content']
            
            return response
        except ValidationError as err:
            abort(400, message=str(err.messages))
        except ValueError as e:
            abort(400, message=str(e))
        except Exception as e:
            abort(500, message=f'Chat failed: {str(e)}')

@chat_blp.route('/history')
class ChatHistory(MethodView):
    @chat_blp.response(200, ChatHistorySchema(many=True))
    @jwt_required()
    def get(self):
        """Get chat history"""
        try:
            user_id = get_jwt_identity()
            chat_service = ChatService()
            history = chat_service.get_chat_history(user_id, limit=50)
            return history
        except Exception as e:
            abort(500, message=str(e))

    @chat_blp.response(200, description="History cleared")
    @jwt_required()
    def delete(self):
        """Clear chat history"""
        try:
            user_id = get_jwt_identity()
            chat_service = ChatService()
            result = chat_service.clear_chat_history(user_id)
            return result
        except Exception as e:
            abort(500, message=str(e))



================================================
File: controllers/.scrap/app_services/guardrails_controller.py
================================================
from flask import request, jsonify
from flask.views import MethodView
from flask_smorest import Blueprint, abort
from flask_jwt_extended import jwt_required
from marshmallow import ValidationError

from services.guardrails_services.guardrails_service import GuardrailsService
from services.auth_services.auth_service import AuthService
from dtos.app_data.guardrails_dto import (
    GuardrailConfigSchema, UpdateGuardrailSchema, CreateGuardrailSchema, GuardrailLogSchema
)

guardrails_blp = Blueprint('guardrails', 'guardrails', url_prefix='/guardrails', description='Guardrails management operations')

@guardrails_blp.route('/config')
class GuardrailConfigList(MethodView):
    @guardrails_blp.response(200, GuardrailConfigSchema(many=True))
    @jwt_required()
    def get(self):
        """Get guardrails configuration"""
        try:
            config = GuardrailsService.get_guardrails_config()
            return config
        except Exception as e:
            abort(500, message=str(e))

    @guardrails_blp.arguments(CreateGuardrailSchema)
    @guardrails_blp.response(201, GuardrailConfigSchema)
    @jwt_required()
    def post(self, data):
        """Create new guardrail rule (admin only)"""
        try:
            AuthService.verify_admin()
            # data is loaded
            rule = GuardrailsService.create_guardrail(**data)
            return rule
        except ValidationError as err:
            abort(400, message=str(err.messages))
        except ValueError as e:
            abort(400, message=str(e))
        except Exception as e:
            abort(500, message=str(e))

@guardrails_blp.route('/config/<int:rule_id>')
class GuardrailConfig(MethodView):
    @guardrails_blp.arguments(UpdateGuardrailSchema)
    @guardrails_blp.response(200, GuardrailConfigSchema)
    @jwt_required()
    def put(self, data, rule_id):
        """Update guardrail configuration (admin only)"""
        try:
            AuthService.verify_admin()
            rule = GuardrailsService.update_guardrail(rule_id, **data)
            return rule
        except ValidationError as err:
            abort(400, message=str(err.messages))
        except ValueError as e:
            abort(400, message=str(e))
        except Exception as e:
            abort(500, message=str(e))

    @guardrails_blp.response(200, description="Rule deleted")
    @jwt_required()
    def delete(self, rule_id):
        """Delete guardrail rule (admin only)"""
        try:
            AuthService.verify_admin()
            result = GuardrailsService.delete_guardrail(rule_id)
            return result
        except ValueError as e:
            abort(400, message=str(e))
        except Exception as e:
            abort(500, message=str(e))

@guardrails_blp.route('/logs')
class GuardrailLogs(MethodView):
    @guardrails_blp.response(200, GuardrailLogSchema(many=True))
    @jwt_required()
    def get(self):
        """Get guardrails detection logs (admin only)"""
        try:
            AuthService.verify_admin()
            logs = GuardrailsService.get_guardrails_logs(limit=100)
            return logs
        except ValueError as e:
            abort(403, message=str(e))
        except Exception as e:
            abort(500, message=str(e))



================================================
File: controllers/.scrap/app_services/rag_controller.py
================================================
from flask import request, jsonify
from flask.views import MethodView
from flask_smorest import Blueprint, abort
from flask_jwt_extended import jwt_required, get_jwt_identity
from marshmallow import ValidationError, Schema, fields
from werkzeug.datastructures import FileStorage

from services.agentic_services.rag_service import RAGService
from services.guardrails_services.guardrails_service import GuardrailsService
from dtos.app_data.rag_dto import (
    DocumentSchema, RagChatRequestSchema, RagChatResponseSchema
)

rag_blp = Blueprint('rag', 'rag', url_prefix='/rag', description='RAG (Retrieval Augmented Generation) operations')

class UploadSchema(Schema):
    file = fields.Raw(type='string', format='binary', required=True, metadata={'description': 'Document file'})

@rag_blp.route('/upload')
class UploadDocument(MethodView):
    @rag_blp.arguments(UploadSchema, location='files')
    @rag_blp.response(201, DocumentSchema)
    @jwt_required()
    def post(self, files):
        """Upload document for RAG"""
        try:
            user_id = get_jwt_identity()
            file = files['file']
            
            # Initialize RAG service
            rag_service = RAGService()
            
            # Upload and process document
            document = rag_service.upload_document(file, user_id)
            
            return document
        except ValueError as e:
            abort(400, message=str(e))
        except Exception as e:
            abort(500, message=f'Upload failed: {str(e)}')

@rag_blp.route('/chat')
class RagChat(MethodView):
    @rag_blp.arguments(RagChatRequestSchema)
    @rag_blp.response(200, RagChatResponseSchema)
    @jwt_required()
    def post(self, data):
        """Chat with documents using RAG"""
        try:
            user_id = get_jwt_identity()
            # data is loaded
            
            # Check guardrails on input
            guardrails_result = GuardrailsService.check_content(
                data['query'],
                user_id,
                'input'
            )
            
            if not guardrails_result['passed']:
                abort(400, message='Content violates guardrails', violations=guardrails_result['violations'])
            
            # Initialize RAG service
            rag_service = RAGService()
            
            # Process chat
            response = rag_service.chat_with_documents(
                query=data['query'],
                user_id=user_id,
                use_internet=data.get('use_internet', False)
            )
            
            # Check guardrails on output
            output_check = GuardrailsService.check_content(
                response['answer'],
                user_id,
                'output'
            )
            
            if not output_check['passed']:
                response['answer'] = output_check['cleaned_content']
            
            return response
        except ValidationError as err:
            abort(400, message=str(err.messages))
        except ValueError as e:
            abort(400, message=str(e))
        except Exception as e:
            abort(500, message=f'Chat failed: {str(e)}')

@rag_blp.route('/documents')
class DocumentList(MethodView):
    @rag_blp.response(200, DocumentSchema(many=True))
    @jwt_required()
    def get(self):
        """Get user's documents"""
        try:
            user_id = get_jwt_identity()
            rag_service = RAGService()
            documents = rag_service.get_user_documents(user_id)
            return documents
        except Exception as e:
            abort(500, message=str(e))

@rag_blp.route('/documents/<int:document_id>')
class Document(MethodView):
    @rag_blp.response(200, description="Document deleted")
    @jwt_required()
    def delete(self, document_id):
        """Delete document"""
        try:
            user_id = get_jwt_identity()
            rag_service = RAGService()
            result = rag_service.delete_document(document_id, user_id)
            return result
        except ValueError as e:
            abort(404, message=str(e))
        except Exception as e:
            abort(500, message=str(e))



================================================
File: controllers/.scrap/auth_services/auth_controller.py
================================================
from flask import request, jsonify
from flask.views import MethodView
from flask_smorest import Blueprint, abort
from flask_jwt_extended import jwt_required

from services.auth_services.auth_service import AuthService
from dtos.auth_data.auth_data import (
    LoginSchema, SignupSchema, UserResponseSchema, CheckEmailSchema,
    AuthResponseSchema, CheckEmailResponseSchema, SignupConfigSchema
)
from dtos.auth_data.otp_data import VerifyOtpSchema

auth_blp = Blueprint('auth', 'auth', url_prefix='/auth', description='Authentication operations')

@auth_blp.route('/check-email')
class CheckEmail(MethodView):
    @auth_blp.arguments(CheckEmailSchema)
    @auth_blp.response(200, CheckEmailResponseSchema)
    def post(self, data):
        """Check if email exists and get role"""
        try:
            result = AuthService.check_user_exists(data['email'])
            return result
        except Exception as e:
            abort(400, message=str(e))

@auth_blp.route('/signup')
class Signup(MethodView):
    @auth_blp.arguments(SignupSchema)
    @auth_blp.response(201, AuthResponseSchema)
    def post(self, data):
        """User registration"""
        try:
            # Check if signup is enabled
            from models import SystemConfig, UserDetailsModel
            config = SystemConfig.query.get('signup_enabled')
            if config and config.value.lower() != 'true':
                if UserDetailsModel.query.count() > 0:
                    abort(403, message="Public registration is currently disabled. Please contact an administrator.")

            result = AuthService.register_user(
                email=data['email'],
                password=data['password'],
                role=data.get('role', 'user'),
                full_name=data.get('full_name')
            )
            return result
        except Exception as e:
            abort(400, message=str(e))

@auth_blp.route('/login')
class Login(MethodView):
    @auth_blp.arguments(LoginSchema)
    @auth_blp.response(200, AuthResponseSchema) 
    def post(self, data):
        """User login"""
        try:
            result = AuthService.login_user(
                email=data['email'],
                password=data['password'],
                role=data.get('role')
            )
            return result
        except Exception as e:
            abort(401, message=str(e))

@auth_blp.route('/verify-otp')
class VerifyOtp(MethodView):
    @auth_blp.arguments(VerifyOtpSchema)
    @auth_blp.response(200, AuthResponseSchema)
    def post(self, data):
        """Verify OTP for 2FA"""
        try:
            result = AuthService.verify_otp(
                email=data['email'],
                otp=data['otp'],
                role=data.get('role')
            )
            return result
        except Exception as e:
            abort(401, message=str(e))

@auth_blp.route('/me')
class Me(MethodView):
    @auth_blp.response(200, UserResponseSchema)
    @jwt_required()
    def get(self):
        """Get current user"""
        try:
            user = AuthService.get_current_user()
            return user
        except Exception as e:
            abort(500, message=str(e))

@auth_blp.route('/config/signup')
class SignupConfigResource(MethodView):
    @auth_blp.response(200, SignupConfigSchema)
    def get(self):
        """Get signup configuration"""
        try:
            from models import SystemConfig
            config = SystemConfig.query.get('signup_enabled')
            return {'enabled': config.value.lower() == 'true' if config else True}
        except Exception as e:
            abort(500, message=str(e))

    @auth_blp.arguments(SignupConfigSchema)
    @auth_blp.response(200, SignupConfigSchema)
    @jwt_required()
    def post(self, data):
        """Update signup configuration (Admin only)"""
        try:
            user = AuthService.get_current_user()
            if not user.is_admin():
                abort(403, message="Admin access required")
            
            enabled = data.get('enabled', True)
            
            from models import SystemConfig, db
            config = SystemConfig.query.get('signup_enabled')
            if not config:
                config = SystemConfig(key='signup_enabled', description='Enable or disable public user registration')
                db.session.add(config)
            
            config.value = str(enabled).lower()
            db.session.commit()
            
            return {'enabled': config.value == 'true', 'message': 'Configuration updated'}
        except Exception as e:
            abort(500, message=str(e))



================================================
File: controllers/.scrap/system_services/domain_controller.py
================================================
from flask.views import MethodView
from flask_smorest import Blueprint, abort
from flask_jwt_extended import jwt_required
from marshmallow import ValidationError

from services.system_services.domain_service import DomainService
from services.auth_services.auth_service import AuthService
from dtos.system_data.domain_dto import DomainSchema, CreateDomainSchema, UpdateDomainSchema

domain_blp = Blueprint('domains', 'domains', url_prefix='/domains', description='Domain management operations')

@domain_blp.route('')
class DomainList(MethodView):
    @domain_blp.response(200, DomainSchema(many=True))
    @jwt_required()
    def get(self):
        """List all domains"""
        try:
            # Check if user is Platform Admin? Or allow all authenticated users to see domains?
            # For now, let's require Platform Admin for management, but maybe read is open?
            # User said: "Platform Admin Can Configure Domain, manage Domains"
            # Let's enforce Platform Admin for now.
            AuthService.verify_platform_admin()
            domains = DomainService.get_all_domains()
            return domains
        except ValueError as e:
            abort(403, message=str(e))
        except Exception as e:
            abort(500, message=str(e))

    @domain_blp.arguments(CreateDomainSchema)
    @domain_blp.response(201, DomainSchema)
    @jwt_required()
    def post(self, data):
        """Create new domain (Platform Admin only)"""
        try:
            AuthService.verify_platform_admin()
            domain = DomainService.create_domain(**data)
            return domain
        except ValidationError as err:
            abort(400, message=str(err.messages))
        except ValueError as e:
            abort(400, message=str(e))
        except Exception as e:
            abort(500, message=str(e))

@domain_blp.route('/<int:domain_id>')
class Domain(MethodView):
    @domain_blp.response(200, DomainSchema)
    @jwt_required()
    def get(self, domain_id):
        """Get domain by ID"""
        try:
            AuthService.verify_platform_admin()
            domain = DomainService.get_domain_by_id(domain_id)
            return domain
        except ValueError as e:
            abort(404, message=str(e))
        except Exception as e:
            abort(500, message=str(e))

    @domain_blp.arguments(UpdateDomainSchema)
    @domain_blp.response(200, DomainSchema)
    @jwt_required()
    def put(self, data, domain_id):
        """Update domain (Platform Admin only)"""
        try:
            AuthService.verify_platform_admin()
            domain = DomainService.update_domain(domain_id, data)
            return domain
        except ValidationError as err:
            abort(400, message=str(err.messages))
        except ValueError as e:
            abort(400, message=str(e))
        except Exception as e:
            abort(500, message=str(e))

    @domain_blp.response(200, description="Domain deleted")
    @jwt_required()
    def delete(self, domain_id):
        """Delete domain (Platform Admin only)"""
        try:
            AuthService.verify_platform_admin()
            result = DomainService.delete_domain(domain_id)
            return result
        except ValueError as e:
            abort(400, message=str(e))
        except Exception as e:
            abort(500, message=str(e))



================================================
File: controllers/.scrap/ui_services/component_controller.py
================================================
from flask import request, jsonify
from flask.views import MethodView
from flask_smorest import Blueprint, abort
from flask_jwt_extended import jwt_required, get_jwt
from marshmallow import ValidationError

from services.ui_services.component_service import ComponentService
from services.auth_services.auth_service import AuthService
from dtos.ui_data.component_dto import (
    ComponentsListSchema, AssignComponentSchema, ComponentAccessSchema,
    ComponentListResponseSchema, NavigationResponseSchema
)

component_blp = Blueprint('components', 'components', url_prefix='/components', description='Component management operations')

@component_blp.route('')
class ComponentList(MethodView):
    # @component_blp.response(200, ComponentsListSchema(many=True)) # Or just list
    # The original code didn't use marshal_with for this endpoint, but it had a commented out line.
    # ComponentService.get_available_components() returns a list of dicts probably.
    # I'll leave it without schema for now or use a generic list schema if I knew it.
    # But wait, `component_list_model` was defined but commented out in usage.
    # I'll assume it returns a list of components.
    @jwt_required()
    def get(self):
        """Get available components"""
        try:
            components = ComponentService.get_available_components()
            return components
        except Exception as e:
            abort(500, message=str(e))

@component_blp.route('/user')
class UserComponents(MethodView):
    @component_blp.response(200, ComponentListResponseSchema)
    @jwt_required()
    def get(self):
        """Get current user's accessible components"""
        try:
            components = ComponentService.get_user_components()
            return {'components': components}
        except Exception as e:
            abort(500, message=str(e))

@component_blp.route('/assign')
class AssignComponent(MethodView):
    @component_blp.arguments(AssignComponentSchema)
    @component_blp.response(200, ComponentAccessSchema)
    @jwt_required()
    def post(self, data):
        """Assign component to role (admin only)"""
        try:
            AuthService.verify_admin()
            # data is loaded
            result = ComponentService.assign_component_to_role(
                role_name=data['role'],
                component_name=data['component_name'],
                has_access=data.get('has_access', True)
            )
            return result
        except ValidationError as err:
            abort(400, message=str(err.messages))
        except ValueError as e:
            abort(400, message=str(e))
        except Exception as e:
            abort(500, message=str(e))

@component_blp.route('/role/<string:role>')
class RoleComponents(MethodView):
    @component_blp.response(200, ComponentListResponseSchema)
    @jwt_required()
    def get(self, role):
        """Get components for a specific role (admin only)"""
        try:
            AuthService.verify_admin()
            components = ComponentService.get_role_components(role)
            return {'components': components}
        except ValueError as e:
            abort(400, message=str(e))
        except Exception as e:
            abort(500, message=str(e))

@component_blp.route('/navigation')
class Navigation(MethodView):
    # @component_blp.response(200, NavigationResponseSchema) # Optional: use schema if available
    @jwt_required()
    def get(self):
        """Get navigation menu for current user based on ACTIVE ROLE from JWT"""
        try:
            # Extract claims from JWT logic
            claims = get_jwt()
            active_role = claims.get('role')

            if not active_role:
                abort(400, message='No active role found in JWT')

            nav_items = ComponentService.get_navigation(active_role)
            return {'navigation': nav_items}

        except Exception as e:
            abort(500, message=str(e))



================================================
File: controllers/.scrap/ui_services/role_controller.py
================================================
from flask import request, jsonify
from flask.views import MethodView
from flask_smorest import Blueprint, abort
from flask_jwt_extended import jwt_required
from marshmallow import ValidationError

from models import db
from models import RoleModel
from services.auth_services.auth_service import AuthService
from dtos.role_dto import RoleSchema, RoleCreateSchema, RoleUpdateSchema, AssignRolesSchema

role_blp = Blueprint('roles', 'roles', url_prefix='/roles', description='Role management operations')

@role_blp.route('')
class RoleList(MethodView):
    @role_blp.response(200, RoleSchema(many=True))
    @jwt_required()
    def get(self):
        """Get all roles"""
        try:
            # Allow any authenticated user to view roles
            roles = RoleModel.query.all()
            return roles
        except Exception as e:
            abort(500, message=str(e))

    @role_blp.arguments(RoleCreateSchema)
    @role_blp.response(201, RoleSchema)
    @jwt_required()
    def post(self, data):
        """Create a new role (Admin only)"""
        try:
            # Verify admin
            user = AuthService.get_current_user()
            if not user.is_admin():
                abort(403, message="Admin access required")
            
            # data is loaded
            
            # Check if role already exists
            if RoleModel.query.filter_by(role_name=data['name']).first():
                abort(400, message=f"Role '{data['name']}' already exists")
            
            # Create role
            role = RoleModel(
                role_name=data['name'],
                description=data.get('description')
            )
            db.session.add(role)
            db.session.commit()
            
            return role
        except ValidationError as err:
            abort(400, message=str(err.messages))
        except ValueError as e:
            abort(400, message=str(e))
        except Exception as e:
            abort(500, message=str(e))

@role_blp.route('/<int:role_id>')
class Role(MethodView):
    @role_blp.response(200, RoleSchema)
    @jwt_required()
    def get(self, role_id):
        """Get a specific role"""
        try:
            role = RoleModel.query.get(role_id)
            if not role:
                abort(404, message="Role not found")
            return role
        except Exception as e:
            abort(500, message=str(e))

    @role_blp.arguments(RoleUpdateSchema)
    @role_blp.response(200, RoleSchema)
    @jwt_required()
    def put(self, data, role_id):
        """Update a role (Admin only)"""
        try:
            # Verify admin
            user = AuthService.get_current_user()
            if not user.is_admin():
                abort(403, message="Admin access required")
            
            role = RoleModel.query.get(role_id)
            if not role:
                abort(404, message="Role not found")
            
            # Prevent modifying default roles
            if role.role_name in ['admin', 'user']:
                abort(400, message="Cannot modify default system roles")
            
            # Update role
            if 'name' in data:
                # Check if new name conflicts
                existing = RoleModel.query.filter_by(role_name=data['name']).first()
                if existing and existing.role_id != role_id:
                    abort(400, message=f"Role '{data['name']}' already exists")
                role.role_name = data['name']
            
            if 'description' in data:
                role.description = data['description']
            
            db.session.commit()
            return role
        except ValidationError as err:
            abort(400, message=str(err.messages))
        except ValueError as e:
            abort(400, message=str(e))
        except Exception as e:
            abort(500, message=str(e))

    @role_blp.response(200, description="Role deleted")
    @jwt_required()
    def delete(self, role_id):
        """Delete a role (Admin only)"""
        try:
            # Verify admin
            user = AuthService.get_current_user()
            if not user.is_admin():
                abort(403, message="Admin access required")
            
            role = RoleModel.query.get(role_id)
            if not role:
                abort(404, message="Role not found")
            
            # Prevent deleting default roles
            if role.role_name in ['admin', 'user']:
                abort(400, message="Cannot delete default system roles")
            
            # Delete role
            db.session.delete(role)
            db.session.commit()
            
            return {'message': f"Role '{role.role_name}' deleted successfully"}
        except ValueError as e:
            abort(400, message=str(e))
        except Exception as e:
            abort(500, message=str(e))

@role_blp.route('/assign')
class RoleAssignment(MethodView):
    @role_blp.arguments(AssignRolesSchema)
    @role_blp.response(200, description="Roles assigned")
    @jwt_required()
    def post(self, data):
        """Assign roles to a user (Admin only)"""
        try:
            # Verify admin
            user = AuthService.get_current_user()
            if not user.is_admin():
                abort(403, message="Admin access required")
            
            AuthService.assign_roles(
                user_id=data['user_id'],
                role_names=data['role_names']
            )
            
            return {'message': 'Roles assigned successfully'}
        except ValidationError as err:
            abort(400, message=str(err.messages))
        except ValueError as e:
            abort(400, message=str(e))
        except Exception as e:
            abort(500, message=str(e))



================================================
File: controllers/.scrap/ui_services/user_controller.py
================================================
from flask import request, jsonify
from flask.views import MethodView
from flask_smorest import Blueprint, abort
from flask_jwt_extended import jwt_required
from marshmallow import ValidationError

from services.system_services.user_service import UserService
from services.auth_services.auth_service import AuthService
from dtos.ui_data.user_dto import (
    UserSchema, CreateUserSchema, UpdateUserSchema
)

user_blp = Blueprint('users', 'users', url_prefix='/users', description='User management operations')

@user_blp.route('')
class UserList(MethodView):
    @user_blp.response(200, UserSchema(many=True))
    @jwt_required()
    def get(self):
        """List all users (admin only)"""
        try:
            AuthService.verify_admin()
            users = UserService.get_all_users()
            return users
        except ValueError as e:
            abort(403, message=str(e))
        except Exception as e:
            abort(500, message=str(e))

    @user_blp.arguments(CreateUserSchema)
    @user_blp.response(201, UserSchema)
    @jwt_required()
    def post(self, data):
        """Create new user (admin only)"""
        try:
            AuthService.verify_admin()
            # data is already loaded
            
            # Handle both old 'role' and new 'roles' parameter
            roles_to_assign = data.get('roles') or [data.get('role', 'user')]
            
            user = AuthService.create_user(
                email=data['email'],
                password=data['password'],
                roles=roles_to_assign,
                full_name=data.get('full_name'),
                file_upload_enabled=data.get('file_upload_enabled', False),
                two_factor_auth_enabled=data.get('two_factor_auth_enabled', False)
            )
            return user
        except ValidationError as err:
            abort(400, message=str(err.messages))
        except ValueError as e:
            abort(400, message=str(e))
        except Exception as e:
            abort(500, message=str(e))

@user_blp.route('/<int:user_id>')
class User(MethodView):
    @user_blp.response(200, UserSchema)
    @jwt_required()
    def get(self, user_id):
        """Get user by ID (admin only)"""
        try:
            AuthService.verify_admin()
            user = UserService.get_user_by_id(user_id)
            return user
        except ValueError as e:
            abort(404, message=str(e))
        except Exception as e:
            abort(500, message=str(e))

    @user_blp.arguments(UpdateUserSchema)
    @user_blp.response(200, UserSchema)
    @jwt_required()
    def put(self, data, user_id):
        """Update user details (admin only)"""
        try:
            AuthService.verify_admin()
            user = UserService.update_user(user_id, data)
            return user
        except ValidationError as err:
            abort(400, message=str(err.messages))
        except ValueError as e:
            abort(400, message=str(e))
        except Exception as e:
            abort(500, message=str(e))

    @user_blp.response(200, description="User deleted")
    @jwt_required()
    def delete(self, user_id):
        """Delete user (admin only)"""
        try:
            AuthService.verify_admin()
            result = UserService.delete_user(user_id)
            return result
        except ValueError as e:
            abort(400, message=str(e))
        except Exception as e:
            abort(500, message=str(e))



================================================
File: data/chroma/chroma.sqlite3
================================================
[Non-text file]




================================================
File: dtos/role_dto.py
================================================
from marshmallow import Schema, fields, validate

class RoleSchema(Schema):
    """Schema for role data - maps DB fields to frontend-friendly names"""
    id = fields.Int(dump_only=True, attribute='role_id')
    name = fields.Str(required=True, validate=validate.Length(min=1, max=50), attribute='role_name')
    description = fields.Str(allow_none=True, validate=validate.Length(max=255))
    created_at = fields.Str(dump_only=True)



class RoleCreateSchema(Schema):
    """Schema for creating a new role"""
    name = fields.Str(required=True, validate=validate.Length(min=1, max=50))
    description = fields.Str(allow_none=True, validate=validate.Length(max=255))


class RoleUpdateSchema(Schema):
    """Schema for updating a role"""
    name = fields.Str(validate=validate.Length(min=1, max=50))
    description = fields.Str(allow_none=True, validate=validate.Length(max=255))


class AssignRolesSchema(Schema):
    """Schema for assigning roles to a user"""
    user_id = fields.Int(required=True)
    role_names = fields.List(fields.Str(), required=True)



================================================
File: dtos/app_data/chat_dto.py
================================================
from marshmallow import Schema, fields

class ToolChatRequestSchema(Schema):
    """Tool chat request schema"""
    message = fields.Str(required=True)

class ToolResultSchema(Schema):
    """Tool result schema"""
    tool = fields.Str()
    input = fields.Str()
    result = fields.Str()

class ToolChatResponseSchema(Schema):
    """Tool chat response schema"""
    answer = fields.Str()
    tools_used = fields.List(fields.Str())
    tool_results = fields.List(fields.Nested(ToolResultSchema))

class ChatHistorySchema(Schema):
    """Chat history schema"""
    id = fields.Int()
    user_id = fields.Int()
    message = fields.Str()
    response = fields.Str()
    chat_type = fields.Str()
    timestamp = fields.Str()
    metadata = fields.Dict()



================================================
File: dtos/app_data/guardrails_dto.py
================================================
from marshmallow import Schema, fields

class GuardrailConfigSchema(Schema):
    """Guardrail config schema"""
    id = fields.Int()
    rule_type = fields.Str()
    enabled = fields.Bool()
    severity = fields.Str()
    description = fields.Str()
    pattern = fields.Str()

class UpdateGuardrailSchema(Schema):
    """Update guardrail schema"""
    enabled = fields.Bool()
    severity = fields.Str()
    description = fields.Str()
    pattern = fields.Str()

class CreateGuardrailSchema(Schema):
    """Create guardrail schema"""
    rule_type = fields.Str(required=True)
    enabled = fields.Bool(missing=True)
    severity = fields.Str(missing='medium')
    description = fields.Str()
    pattern = fields.Str()

class GuardrailLogSchema(Schema):
    """Guardrail log schema"""
    id = fields.Int()
    user_id = fields.Int()
    user_email = fields.Str()
    detected_rule = fields.Str()
    content_snippet = fields.Str()
    timestamp = fields.Str()
    action_taken = fields.Str()



================================================
File: dtos/app_data/rag_dto.py
================================================
from marshmallow import Schema, fields

class DocumentSchema(Schema):
    """Document schema"""
    id = fields.Int()
    filename = fields.Str()
    user_id = fields.Int()
    uploaded_at = fields.Str(attribute='created_at')
    file_size = fields.Int(allow_none=True)

class RagChatRequestSchema(Schema):
    """RAG chat request schema"""
    query = fields.Str(required=True)
    use_internet = fields.Bool(missing=False)

class SourceSchema(Schema):
    """Source schema"""
    content = fields.Str()
    metadata = fields.Dict()

class RagChatResponseSchema(Schema):
    """RAG chat response schema"""
    answer = fields.Str()
    sources = fields.List(fields.Nested(SourceSchema))
    use_internet = fields.Bool()



================================================
File: dtos/auth_data/auth_data.py
================================================
from marshmallow import Schema, fields, ValidationError


# Schemas
class SignupSchema(Schema):
    """Signup request schema"""
    email = fields.Email(required=True)
    password = fields.Str(required=True, validate=lambda p: len(p) >= 6)
    role = fields.Str(missing='user', validate=lambda r: r in ['user', 'admin'])
    full_name = fields.Str(missing=None)

class CheckEmailSchema(Schema):
    """Check email schema"""
    email = fields.Email(required=True)

class LoginSchema(Schema):
    """Login request schema"""
    email = fields.Email(required=True)
    password = fields.Str(required=True)
    role = fields.Str(required=False)

class UserResponseSchema(Schema):
    """User response schema"""
    id = fields.Int()
    email = fields.Email()
    full_name = fields.Str(allow_none=True)
    roles = fields.List(fields.Str())
    created_at = fields.Str()

class SignupConfigSchema(Schema):
    """Signup configuration schema"""
    enabled = fields.Bool(required=True, description='Enable/Disable signup')

class SwitchDomainSchema(Schema):
    """Switch domain request schema"""
    domain_id = fields.Int(required=True)

class AuthResponseSchema(Schema):
    """Authentication response schema"""
    user = fields.Nested(UserResponseSchema)
    access_token = fields.Str()
    requires_2fa = fields.Bool()
    domains = fields.List(fields.Dict())

class CheckEmailResponseSchema(Schema):
    """Check email response schema"""
    exists = fields.Bool()
    roles = fields.List(fields.Str())
    full_name = fields.Str()



================================================
File: dtos/auth_data/otp_data.py
================================================
from marshmallow import Schema,fields

# Additional Schemas
class VerifyOtpSchema(Schema):
    email = fields.Email(required=True)
    otp = fields.Str(required=True)
    role = fields.Str(allow_none=True)


================================================
File: dtos/system_data/domain_dto.py
================================================
from marshmallow import Schema, fields

class DomainSchema(Schema):
    """Domain response schema"""
    domain_id = fields.Int(dump_only=True)
    domain_name = fields.Str(required=True)
    description = fields.Str()
    active_flag = fields.Bool()
    created_at = fields.Str(dump_only=True)

class CreateDomainSchema(Schema):
    """Create domain schema"""
    domain_name = fields.Str(required=True)
    description = fields.Str()

class UpdateDomainSchema(Schema):
    """Update domain schema"""
    domain_name = fields.Str()
    description = fields.Str()
    active_flag = fields.Bool()



================================================
File: dtos/ui_data/component_dto.py
================================================
from marshmallow import Schema, fields

class ComponentsListSchema(Schema):
    """Components list schema"""
    assignable = fields.List(fields.Str())
    admin_only = fields.List(fields.Str())

class AssignComponentSchema(Schema):
    """Assign component schema"""
    role = fields.Str(required=True)
    component_name = fields.Str(required=True)
    has_access = fields.Bool(missing=True)

class ComponentAccessSchema(Schema):
    """Component access schema"""
    id = fields.Int(attribute='template_role_id')
    role = fields.Str(attribute='role_name')
    component_name = fields.Str(attribute='template_name')
    has_access = fields.Bool(attribute='active_flag')

class ComponentListResponseSchema(Schema):
    """Component list response schema"""
    components = fields.List(fields.Str())

class NavigationItemSchema(Schema):
    """Navigation item schema"""
    name = fields.Str()
    label = fields.Str()
    icon = fields.Str()
    description = fields.Str(allow_none=True)
    admin_only = fields.Bool()
    mode = fields.Str(allow_none=True)
    value = fields.Str(allow_none=True)

class NavigationResponseSchema(Schema):
    """Navigation response schema"""
    navigation = fields.List(fields.Nested(NavigationItemSchema))



================================================
File: dtos/ui_data/user_dto.py
================================================
from marshmallow import Schema, fields, validate

class UserSchema(Schema):
    """User schema"""
    id = fields.Int(attribute='user_id')
    email = fields.Email()
    full_name = fields.Str(attribute='name', allow_none=True)
    roles = fields.Method("get_roles")
    file_upload_enabled = fields.Bool()
    two_factor_auth_enabled = fields.Bool()
    created_at = fields.Str()

    def get_roles(self, obj):
        if hasattr(obj, 'get_role_names'):
            return obj.get_role_names()
        return []

class CreateUserSchema(Schema):
    """Schema for creating a new user"""
    email = fields.Str(required=True, validate=validate.Email())
    password = fields.Str(required=True, validate=validate.Length(min=6))
    role = fields.Str(validate=validate.OneOf(['user', 'admin']), missing='user')  # Backward compatibility
    roles = fields.List(fields.Str(), missing=None)  # New RBAC field
    full_name = fields.Str(allow_none=True, missing=None)
    file_upload_enabled = fields.Bool(missing=False)
    two_factor_auth_enabled = fields.Bool(missing=False)

class UpdateUserSchema(Schema):
    """Schema for updating user details"""
    full_name = fields.Str(allow_none=True)
    role = fields.Str(validate=validate.OneOf(['user', 'admin']))  # Backward compatibility
    roles = fields.List(fields.Str(), allow_none=True)  # New RBAC field
    file_upload_enabled = fields.Bool(allow_none=True)
    two_factor_auth_enabled = fields.Bool(allow_none=True)



================================================
File: instance/app.db
================================================
[Non-text file]


================================================
File: migrations/init_db.py
================================================
from abc import ABC, abstractmethod
from models import db
from models import UserDetailsModel, RoleModel, UserRoleMappingModel, ComponentModel, ComponentRoleMappingModel, SystemConfig
from services.auth_services.auth_service import AuthService

class DatabaseInitializer(ABC):
    def __init__(self, app):
        self.app = app

    def run(self):
        """Main execution flow"""
        with self.app.app_context():
            self.create_schemas()
            self.create_tables()
            self.seed_data()

    @abstractmethod
    def create_schemas(self):
        """Create necessary database schemas"""
        pass

    def create_tables(self):
        """Create tables using SQLAlchemy"""
        print("Creating database tables...")
        try:
            print("Registered tables:", db.metadata.tables.keys())
            db.create_all()
        except Exception as e:
            print(f"Error creating tables: {e}")
            raise e

    def seed_data(self):
        """Seed default data (roles, users, config, etc.)"""
        
        # ---------------------------------------------
        # 2. Create default roles
        # ---------------------------------------------
        print("Creating default roles...")
        roles_data = [
            {'role_name': 'Platform Admin', 'description': 'Super admin with domain management and system log access, cannot use domains directly'},
            {'role_name': 'admin', 'description': 'Domain administrator with full access to assigned domain components'},
            {'role_name': 'moderator', 'description': 'Domain moderator with limited administrative access to assigned domains'},
            {'role_name': 'user', 'description': 'Regular user with standard access to assigned domains'},
        ]

        roles = {}
        for role_data in roles_data:
            role = RoleModel.query.filter_by(role_name=role_data['role_name']).first()
            if not role:
                role = RoleModel(**role_data)
                db.session.add(role)
                db.session.flush()
            roles[role_data['role_name']] = role

        db.session.commit()
        print(f"✓ Created roles: {', '.join(roles.keys())}")

        # ---------------------------------------------
        # 3. Create default domains
        # ---------------------------------------------
        print("Creating default domains...")
        from models import DomainModel
        domains_data = [
            {'domain_name': 'Agentic Domain', 'domain_type': 'Agentic', 'description': 'AI-powered document chat and tool calling domain'},
            {'domain_name': 'Guardrails Domain', 'domain_type': 'Guardrails', 'description': 'Security and safety guardrails domain'},
        ]

        domains = {}
        for domain_data in domains_data:
            domain = DomainModel.query.filter_by(domain_name=domain_data['domain_name']).first()
            if not domain:
                domain = DomainModel(**domain_data)
                db.session.add(domain)
                db.session.flush()
            domains[domain_data['domain_name']] = domain

        db.session.commit()
        print(f"✓ Created domains: {', '.join(domains.keys())}")

        # ---------------------------------------------
        # 4. Create default admin user (with domain access)
        # ---------------------------------------------
        admin_email = 'admin@mail.com'
        admin = UserDetailsModel.query.filter_by(email=admin_email).first()

        if not admin:
            try:
                admin = UserDetailsModel(
                    name='Domain Administrator',
                    email=admin_email,
                    two_factor_auth_enabled=False,
                    file_upload_enabled=True,
                    active_flag=True
                )
                admin.set_password('password')
                db.session.add(admin)
                db.session.flush()

                # Assign admin role to both domains
                for domain_name in ['Agentic Domain', 'Guardrails Domain']:
                    admin_role_mapping = UserRoleMappingModel(
                        user_id=admin.user_id,
                        role_id=roles['admin'].role_id,
                        domain_id=domains[domain_name].domain_id,
                        active_flag=True
                    )
                    db.session.add(admin_role_mapping)
                
                db.session.commit()
                print(f"✓ Created default admin: {admin_email} / password (2FA disabled)")
                print(f"  Assigned to domains: Agentic Domain, Guardrails Domain")

            except Exception as e:
                print(f"Error creating admin user: {e}")
                db.session.rollback()

        else:
            admin.two_factor_auth_enabled = False
            # Ensure admin has role mappings for both domains
            for domain_name in ['Agentic Domain', 'Guardrails Domain']:
                mapping = UserRoleMappingModel.query.filter_by(
                    user_id=admin.user_id,
                    role_id=roles['admin'].role_id,
                    domain_id=domains[domain_name].domain_id
                ).first()
                
                if not mapping:
                    admin_role_mapping = UserRoleMappingModel(
                        user_id=admin.user_id,
                        role_id=roles['admin'].role_id,
                        domain_id=domains[domain_name].domain_id,
                        active_flag=True
                    )
                    db.session.add(admin_role_mapping)

            db.session.commit()
            print(f"✓ Updated existing admin user: {admin_email}")

        # ---------------------------------------------
        # 5. Create Platform Admin user (no domain access)
        # ---------------------------------------------
        platform_admin_email = 'platform@mail.com'
        platform_admin = UserDetailsModel.query.filter_by(email=platform_admin_email).first()

        if not platform_admin:
            try:
                platform_admin = UserDetailsModel(
                    name='Platform Administrator',
                    email=platform_admin_email,
                    two_factor_auth_enabled=False,
                    file_upload_enabled=False,
                    active_flag=True
                )
                platform_admin.set_password('platform')
                db.session.add(platform_admin)
                db.session.flush()

                # Assign Platform Admin role (no domain_id - global role)
                platform_role_mapping = UserRoleMappingModel(
                    user_id=platform_admin.user_id,
                    role_id=roles['Platform Admin'].role_id,
                    domain_id=None,  # No domain access
                    active_flag=True
                )
                db.session.add(platform_role_mapping)
                db.session.commit()

                print(f"✓ Created Platform Admin: {platform_admin_email} / platform (2FA disabled)")

            except Exception as e:
                print(f"Error creating platform admin user: {e}")
                db.session.rollback()

        else:
            platform_admin.two_factor_auth_enabled = False
            if not platform_admin.has_role('Platform Admin'):
                platform_role_mapping = UserRoleMappingModel(
                    user_id=platform_admin.user_id,
                    role_id=roles['Platform Admin'].role_id,
                    domain_id=None,
                    active_flag=True
                )
                db.session.add(platform_role_mapping)

            db.session.commit()
            print(f"✓ Updated existing platform admin user: {platform_admin_email}")

        # ---------------------------------------------
        # 4. Initialize Guardrails
        # ---------------------------------------------
        print("Initializing guardrails...")
        from services.guardrails_services.guardrails_service import GuardrailsService
        GuardrailsService.initialize_defaults()

        # ---------------------------------------------
        # 5. Initialize System Config
        # ---------------------------------------------
        print("Initializing system config...")
        if not SystemConfig.query.get('signup_enabled'):
            signup_config = SystemConfig(
                key='signup_enabled',
                value='true',
                description='Enable or disable public user registration'
            )
            db.session.add(signup_config)
            db.session.commit()

        # ---------------------------------------------
        # 6. Navigation items / Components
        # ---------------------------------------------
        nav_items = [
            # Agentic Domain Components
            {
                'name': 'AGENTIC_RAG',
                'label': 'Agentic RAG',
                'icon': '📚',
                "mode": "path",
                "value": "rag",
                'description': 'Chat with your documents using AI',
                'domain': 'Agentic Domain',
                'roles': ['admin', 'user']
            },
            {
                'name': 'NORMAL_CHAT',
                'label': 'Tool Chat',
                'icon': '💬',
                "mode": "path",
                "value": "chat",
                'description': 'General AI chat with tool capabilities',
                'domain': 'Agentic Domain',
                'roles': ['admin', 'user']
            },
            # Guardrails Domain Components
            {
                'name': 'GUARDRAILS_INSIGHTS',
                'label': 'Guardrails Insights',
                'icon': '🛡️',
                "mode": "path",
                "value": "guardrails",
                'description': 'View security and safety alerts',
                'domain': 'Guardrails Domain',
                'roles': ['admin', 'user']
            },
            {
                'name': 'GUARDRAILS_CONFIGURATION',
                'label': 'Guardrails Config',
                'icon': '⚙️',
                "mode": "path",
                "value": "guardrails/config",
                'description': 'Configure safety guardrails',
                'domain': 'Guardrails Domain',
                'roles': ['admin']
            },
            # Shared/Admin Components (in both domains)
            {
                'name': 'USER_MANAGEMENT',
                'label': 'User Management',
                'icon': '👥',
                "mode": "path",
                "value": "users",
                'description': 'Manage domain users',
                'domain': 'Agentic Domain',
                'roles': ['admin']
            },
            {
                'name': 'USER_MANAGEMENT_GR',
                'label': 'User Management',
                'icon': '👥',
                "mode": "path",
                "value": "users",
                'description': 'Manage domain users',
                'domain': 'Guardrails Domain',
                'roles': ['admin']
            },
            {
                'name': 'COMPONENT_MANAGEMENT',
                'label': 'Component Management',
                'icon': '🔧',
                "mode": "path",
                "value": "components",
                'description': 'Manage component access',
                'domain': 'Agentic Domain',
                'roles': ['admin']
            },
            {
                'name': 'ROLE_MANAGEMENT',
                'label': 'Role Management',
                'icon': '🔐',
                "mode": "path",
                "value": "roles",
                'description': 'Manage roles and permissions',
                'domain': 'Agentic Domain',
                'roles': ['admin']
            },
            # Platform Admin Components (no domain)
            {
                'name': 'DOMAIN_MANAGEMENT',
                'label': 'Domain Management',
                'icon': '🌐',
                "mode": "path",
                "value": "domains",
                'description': 'Manage system domains',
                'domain': None,
                'roles': ['Platform Admin']
            },
            {
                'name': 'SYSTEM_LOGS',
                'label': 'System Logs',
                'icon': '📊',
                "mode": "path",
                "value": "logs",
                'description': 'View system audit logs',
                'domain': None,
                'roles': ['Platform Admin']
            },
            {
                'name': 'USER_DOMAIN_ASSIGNMENT',
                'label': 'User-Domain Assignment',
                'icon': '🔗',
                "mode": "path",
                "value": "user-domains",
                'description': 'Assign users to domains',
                'domain': None,
                'roles': ['Platform Admin']
            }
        ]

        # ---------------------------------------------
        # 7. Insert/Update components + role mapping
        # ---------------------------------------------
        print("Initializing navigation components...")

        for item_data in nav_items:

            # Get domain_id if domain is specified
            domain_id = None
            if item_data.get('domain'):
                domain_obj = domains.get(item_data['domain'])
                if domain_obj:
                    domain_id = domain_obj.domain_id

            # Create or update ComponentModel
            template = ComponentModel.query.filter_by(template_name=item_data['name']).first()

            if not template:
                template = ComponentModel(
                    template_name=item_data['name'],
                    template_icon=item_data['icon'],
                    description=item_data['description'],
                    component_mode=item_data["mode"],  
                    component_value=item_data["value"],
                    domain_id=domain_id,
                    active_flag=True
                )
                db.session.add(template)
                db.session.flush()

            else:
                template.template_icon = item_data['icon']
                template.description = item_data['description']
                template.component_mode = item_data['mode']
                template.component_value = item_data['value']
                template.domain_id = domain_id

            # Create role mappings
            for role_name in item_data['roles']:
                role = roles.get(role_name)
                if not role:
                    continue

                mapping = ComponentRoleMappingModel.query.filter_by(
                    role_id=role.role_id,
                    template_id=template.template_id
                ).first()

                if not mapping:
                    mapping = ComponentRoleMappingModel(
                        role_id=role.role_id,
                        template_id=template.template_id,
                        active_flag=True
                    )
                    db.session.add(mapping)

        db.session.commit()

        print("✓ Database initialization complete!")
        print(f"✓ Admin has access to all {len(nav_items)} components")
        print("✓ Default credentials: admin@mail.com / password (2FA disabled)")


class DuckDBInitializer(DatabaseInitializer):
    def create_schemas(self):
        print("Creating database schemas (DuckDB)...")
        try:
            schemas = ['auth_schema', 'system_schema', 'agentic_schema', 'guardrails_schema']
            for schema in schemas:
                db.session.execute(db.text(f"CREATE SCHEMA IF NOT EXISTS {schema}"))
            db.session.commit()
            print(f"✓ Created schemas: {', '.join(schemas)}")
        except Exception as e:
            print(f"Note: Schema creation - {e}")
            db.session.rollback()


class PostgresInitializer(DatabaseInitializer):
    def create_schemas(self):
        print("Creating database schemas (PostgreSQL)...")
        try:
            schemas = ['auth_schema', 'system_schema', 'agentic_schema', 'guardrails_schema']
            for schema in schemas:
                db.session.execute(db.text(f"CREATE SCHEMA IF NOT EXISTS {schema}"))
            db.session.commit()
            print(f"✓ Created schemas: {', '.join(schemas)}")
        except Exception as e:
            print(f"Error creating schemas: {e}")
            db.session.rollback()
            # For Postgres, we might want to raise, but let's log and continue to see if create_all works
            # raise e


def init_db(app):
    """Factory function to select and run the appropriate initializer"""
    uri = app.config.get('SQLALCHEMY_DATABASE_URI', '')
    
    if 'duckdb' in uri:
        print("Detected DuckDB. Using DuckDBInitializer.")
        initializer = DuckDBInitializer(app)
    else:
        print("Detected PostgreSQL (or other). Using PostgresInitializer.")
        initializer = PostgresInitializer(app)
        
    initializer.run()



================================================
File: models/__init__.py
================================================
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()

# Import models so they are registered with SQLAlchemy
from .auth_models.role_entity import RoleModel
from .auth_models.user_entity import UserDetailsModel
from .auth_models.mapping_entities import UserRoleMappingModel

from .system_models.managemnt_models import SystemConfig, DomainModel
from .system_models.template_models.template_entity import ComponentModel
from .system_models.template_models.mapping_entities import ComponentRoleMappingModel

from .components.guardrails_models.gr_config_entity import GuardrailsConfig
from .components.guardrails_models.gr_log_entity import GuardrailsLog

from .components.agentic_models.chat_entity import ChatHistory
from .components.agentic_models.document_entity import Document





================================================
File: models/auth_models/mapping_entities.py
================================================
from .. import db
from datetime import datetime
import bcrypt



class UserRoleMappingModel(db.Model):
    __tablename__ = "user_role_mapping"
    __table_args__ = {'schema': 'auth_schema'}

    user_role_id = db.Column(db.Integer, db.Sequence('user_role_id_seq'), primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey("auth_schema.users.user_id"), nullable=False)
    role_id = db.Column(db.Integer, db.ForeignKey("auth_schema.roles.role_id"), nullable=False)
    domain_id = db.Column(db.Integer, nullable=True)  # References system_schema.domains.domain_id (FK removed for DuckDB cross-schema compatibility)

    active_flag = db.Column(db.Boolean, nullable=False, default=True)
    description = db.Column(db.String(255))

    # relationships
    user = db.relationship("UserDetailsModel", backref="user_roles")
    role = db.relationship("RoleModel", backref="role_users")
    domain = db.relationship("DomainModel", foreign_keys=[domain_id], primaryjoin="UserRoleMappingModel.domain_id == DomainModel.domain_id", backref="domain_users")

    def to_dict(self):
        return {
            'user_role_id': self.user_role_id,
            'user_id': self.user_id,
            'role_id': self.role_id,
            'domain_id': self.domain_id,
            'active_flag': self.active_flag,
            'description': self.description
        }



================================================
File: models/auth_models/role_entity.py
================================================
from .. import db
from datetime import datetime
import bcrypt


class RoleModel(db.Model):
    __tablename__ = "roles"
    __table_args__ = {'schema': 'auth_schema'}

    role_id = db.Column(db.Integer, db.Sequence('role_id_seq'), primary_key=True)
    role_name = db.Column(db.String(100), nullable=False, unique=True)
    description = db.Column(db.String(255))
    active_flag = db.Column(db.Boolean, nullable=False, default=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

    def to_dict(self):
        return {
            'role_id': self.role_id,
            'role_name': self.role_name,
            'description': self.description,
            'active_flag': self.active_flag,
            'created_at': self.created_at.isoformat() if self.created_at else None
        }


================================================
File: models/auth_models/user_entity.py
================================================
from .. import db
from datetime import datetime
import bcrypt


class UserDetailsModel(db.Model):
    __tablename__ = "users"
    __table_args__ = {'schema': 'auth_schema'}

    user_id = db.Column(db.Integer, db.Sequence('user_id_seq'), primary_key=True)
    name = db.Column(db.String(120), nullable=False)
    email = db.Column(db.String(120), nullable=False, unique=True)
    user_password = db.Column(db.String(200), nullable=False)
    active_flag = db.Column(db.Boolean, nullable=False, default=True)
    
    # New fields
    file_upload_enabled = db.Column(db.Boolean, default=False)
    two_factor_auth_enabled = db.Column(db.Boolean, default=False)
    otp_secret = db.Column(db.String(100), nullable=True)
    otp_expiry = db.Column(db.DateTime, nullable=True)
    
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

    def set_password(self, password):
        self.user_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')

    def check_password(self, password):
        return bcrypt.checkpw(password.encode('utf-8'), self.user_password.encode('utf-8'))

    def has_role(self, role_name):
        """Check if user has a specific role"""
        # user_roles is the backref from UserRoleMappingModel
        return any(ur.role.role_name == role_name for ur in self.user_roles if ur.active_flag)

    def is_admin(self):
        """Check if user has admin role"""
        return self.has_role('admin')

    def get_role_names(self):
        """Get list of role names"""
        return [ur.role.role_name for ur in self.user_roles if ur.active_flag]

    def get_user_domains(self):
        """Get list of domains user has access to with their roles"""
        domains = []
        seen_domains = set()
        for ur in self.user_roles:
            if ur.active_flag and ur.domain_id and ur.domain:
                if ur.domain_id not in seen_domains:
                    domains.append({
                        'domain_id': ur.domain.domain_id,
                        'domain_name': ur.domain.domain_name,
                        'domain_type': ur.domain.domain_type,
                        'role': ur.role.role_name
                    })
                    seen_domains.add(ur.domain_id)
        return domains

    def to_dict(self):
        return {
            'user_id': self.user_id,
            'name': self.name,
            'email': self.email,
            'roles': self.get_role_names(),
            'active_flag': self.active_flag,
            'file_upload_enabled': self.file_upload_enabled,
            'two_factor_auth_enabled': self.two_factor_auth_enabled,
            'created_at': self.created_at.isoformat() if self.created_at else None
        }



================================================
File: models/components/agentic_models/chat_entity.py
================================================
from ... import db
from datetime import datetime

class ChatHistory(db.Model):
    """Chat history model"""
    __tablename__ = 'chat_history'
    __table_args__ = {'schema': 'agentic_schema'}
    
    id = db.Column(db.Integer, db.Sequence('chat_history_id_seq'), primary_key=True)
    user_id = db.Column(db.Integer, nullable=False)
    message = db.Column(db.Text, nullable=False)
    response = db.Column(db.Text, nullable=False)
    chat_type = db.Column(db.String(50), nullable=False)  # 'rag' or 'tool'
    timestamp = db.Column(db.DateTime, default=datetime.utcnow, index=True)
    extra_metadata = db.Column(db.JSON, nullable=True)  # Additional metadata (tools used, sources, etc.)
    
    def to_dict(self):
        """Convert chat history to dictionary"""
        return {
            'id': self.id,
            'user_id': self.user_id,
            'message': self.message,
            'response': self.response,
            'chat_type': self.chat_type,
            'timestamp': self.timestamp.isoformat(),
            'metadata': self.extra_metadata
        }



================================================
File: models/components/agentic_models/document_entity.py
================================================
from ... import db
from datetime import datetime

class Document(db.Model):
    """Document model for RAG system"""
    __tablename__ = 'documents'
    __table_args__ = {'schema': 'agentic_schema'}
    
    id = db.Column(db.Integer, db.Sequence('document_id_seq'), primary_key=True)
    filename = db.Column(db.String(255), nullable=False)
    filepath = db.Column(db.String(500), nullable=False)
    user_id = db.Column(db.Integer, nullable=False)
    uploaded_at = db.Column(db.DateTime, default=datetime.utcnow)
    vector_store_id = db.Column(db.String(100), nullable=True)  # Chroma collection ID
    file_size = db.Column(db.Integer, nullable=True)  # File size in bytes
    
    def to_dict(self):
        """Convert document to dictionary"""
        return {
            'id': self.id,
            'filename': self.filename,
            'user_id': self.user_id,
            'uploaded_at': self.uploaded_at.isoformat(),
            'file_size': self.file_size
        }



================================================
File: models/components/guardrails_models/gr_config_entity.py
================================================
from datetime import datetime
from ... import db

class GuardrailsConfig(db.Model):
    """Guardrails configuration model"""
    __tablename__ = 'guardrails_config'
    __table_args__ = {'schema': 'guardrails_schema'}
    
    id = db.Column(db.Integer, db.Sequence('gr_config_id_seq'), primary_key=True)
    rule_type = db.Column(db.String(100), nullable=False, unique=True)
    enabled = db.Column(db.Boolean, default=True)
    severity = db.Column(db.String(20), default='medium')  # 'low', 'medium', 'high'
    description = db.Column(db.Text, nullable=True)
    pattern = db.Column(db.Text, nullable=True)  # Regex pattern or keywords
    
    def to_dict(self):
        """Convert guardrails config to dictionary"""
        return {
            'id': self.id,
            'rule_type': self.rule_type,
            'enabled': self.enabled,
            'severity': self.severity,
            'description': self.description,
            'pattern': self.pattern
        }



================================================
File: models/components/guardrails_models/gr_log_entity.py
================================================
from datetime import datetime
from ... import db
from ...auth_models.user_entity import UserDetailsModel

class GuardrailsLog(db.Model):
    """Guardrails detection log model"""
    __tablename__= 'guardrails_logs'
    __table_args__ = {'schema': 'guardrails_schema'}
    
    id = db.Column(db.Integer, db.Sequence('gr_log_id_seq'), primary_key=True)
    user_id = db.Column(db.Integer, nullable=False)
    guardrail_id = db.Column(db.Integer, nullable=True)
    detected_rule = db.Column(db.String(100), nullable=False)
    content_snippet = db.Column(db.Text, nullable=True)  # Snippet of flagged content
    timestamp = db.Column(db.DateTime, default=datetime.utcnow, index=True)
    action_taken = db.Column(db.String(50), default='blocked')  # 'blocked', 'warned', 'logged'
    
    def to_dict(self):
        """Convert guardrails log to dictionary"""
        user = UserDetailsModel.query.get(self.user_id)
        return {
            'id': self.id,
            'user_id': self.user_id,
            'user_email': user.email if user else 'Unknown',
            'detected_rule': self.detected_rule,
            'content_snippet': self.content_snippet,
            'timestamp': self.timestamp.isoformat(),
            'action_taken': self.action_taken
        }



================================================
File: models/system_models/managemnt_models.py
================================================
from .. import db
from datetime import datetime

class SystemConfig(db.Model):
    """System configuration settings"""
    __tablename__ = 'system_config'
    __table_args__ = {'schema': 'system_schema'}
    
    key = db.Column(db.String(50), primary_key=True)
    value = db.Column(db.String(255), nullable=False)
    description = db.Column(db.String(255), nullable=True)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    def to_dict(self):
        return {
            'key': self.key,
            'value': self.value,
            'description': self.description,
            'updated_at': self.updated_at.isoformat()
        }

class DomainModel(db.Model):
    """Domain configuration (e.g., Agentic, Guardrails)"""
    __tablename__ = 'domains'
    __table_args__ = {'schema': 'system_schema'}

    domain_id = db.Column(db.Integer, db.Sequence('domain_id_seq'), primary_key=True)
    domain_name = db.Column(db.String(100), nullable=False, unique=True)
    domain_type = db.Column(db.String(50), nullable=False, default='Agentic')  # Agentic, Guardrails, etc.
    description = db.Column(db.String(255))
    active_flag = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

    def to_dict(self):
        return {
            'domain_id': self.domain_id,
            'domain_name': self.domain_name,
            'domain_type': self.domain_type,
            'description': self.description,
            'active_flag': self.active_flag,
            'created_at': self.created_at.isoformat()
        }



================================================
File: models/system_models/template_models/mapping_entities.py
================================================
from ... import db

class ComponentRoleMappingModel(db.Model):
    __tablename__ = "template_role_mapping"
    __table_args__ = {'schema': 'system_schema'}

    template_role_id = db.Column(db.Integer, db.Sequence('template_role_id_seq'), primary_key=True)
    template_id = db.Column(db.Integer, db.ForeignKey("system_schema.templates.template_id"), nullable=False)
    role_id = db.Column(db.Integer, nullable=False)

    active_flag = db.Column(db.Boolean, nullable=False, default=True)

    # relationships
    template = db.relationship("ComponentModel", backref="template_roles")
    role = db.relationship("RoleModel", primaryjoin="foreign(ComponentRoleMappingModel.role_id) == remote(RoleModel.role_id)", backref="role_templates")

    def to_dict(self):
        return {
            'template_role_id': self.template_role_id,
            'template_id': self.template_id,
            'role_id': self.role_id,
            'active_flag': self.active_flag
        }


================================================
File: models/system_models/template_models/template_entity.py
================================================
from ... import db


class ComponentModel(db.Model):
    __tablename__ = "templates"
    __table_args__ = {'schema': 'system_schema'}

    template_id = db.Column(db.Integer, db.Sequence('template_id_seq'), primary_key=True)
    template_name = db.Column(db.String(120), nullable=False, unique=True)
    template_icon = db.Column(db.String(100))
    description = db.Column(db.String(255))
    component_mode = db.Column(db.String(255), nullable=False) #'VALUE SHOULD BE : COMPONENT/PATH'
    component_value = db.Column(db.String(255), nullable=False) #'Respective VALUE SHOULD STORE If component then component name if path then Path value' 
    domain_id = db.Column(db.Integer, db.ForeignKey("system_schema.domains.domain_id"), nullable=True)
    active_flag = db.Column(db.Boolean, nullable=False, default=True)

    def to_dict(self):
        return {
            'template_id': self.template_id,
            'template_icon': self.template_icon,
            'template_name': self.template_name,
            'description': self.description,
            'component_mode': self.component_mode,
            'component_value': self.component_value,
            'domain_id': self.domain_id,
            'active_flag': self.active_flag
        }



================================================
File: services/__init__.py
================================================
# Services package
from .auth_services.auth_service import AuthService
from .auth_services.email_service import EmailService
from .ui_services.component_service import ComponentService
from .guardrails_services.guardrails_service import GuardrailsService
from .agentic_services.chat_service import ChatService
from .agentic_services.rag_service import RAGService
from .system_services.user_service import UserService

__all__ = [
    'AuthService',
    'EmailService',
    'UserService',
    'ComponentService',
    'RAGService',
    'ChatService',
    'GuardrailsService'
]



================================================
File: services/agentic_services/chat_service.py
================================================
import os
import base64
from typing import Optional, List
import requests
from langchain_openai import ChatOpenAI
from langchain_community.tools import DuckDuckGoSearchRun
from langchain_core.messages import HumanMessage

from models import db
from models import ChatHistory
from services.auth_services.auth_service import AuthService
from configs.app_config import Config

class ChatService:
    """LangGraph tool calling chat service with OpenAI Vision support"""
    
    def __init__(self):
        """Initialize chat service"""
        if not Config.OPENAI_API_KEY:
            raise ValueError('OpenAI API key not configured')
        
        # Initialize OpenAI model with vision support
        self.llm = ChatOpenAI(
            model=Config.OPENAI_MODEL,
            openai_api_key=Config.OPENAI_API_KEY,
            temperature=0.7
        )
        
        # Initialize tools
        self.tools = self._initialize_tools()
    
    def _initialize_tools(self):
        """Initialize available tools"""
        tools = {
            'web_search': {
                'name': 'web_search',
                'description': 'Search the internet for current information',
                'func': self._web_search
            },
            'api_call': {
                'name': 'api_call',
                'description': 'Make HTTP GET request to a URL',
                'func': self._api_call
            },
            'calculator': {
                'name': 'calculator',
                'description': 'Perform mathematical calculations',
                'func': self._calculator
            }
        }
        return tools
    
    def _web_search(self, query: str) -> str:
        """Web search using DuckDuckGo"""
        try:
            search = DuckDuckGoSearchRun()
            result = search.run(query)
            return result
        except Exception as e:
            return f"Search error: {str(e)}"
    
    def _api_call(self, url: str) -> str:
        """Make API call to URL"""
        try:
            if not url.startswith(('http://', 'https://')):
                return "Error: URL must start with http:// or https://"
            
            response = requests.get(url, timeout=10)
            response.raise_for_status()
            
            # Try to return JSON if available
            try:
                return str(response.json())[:1000]  # Limit response size
            except:
                return response.text[:1000]
        except Exception as e:
            return f"API call error: {str(e)}"
    
    def _calculator(self, expression: str) -> str:
        """Safe calculator evaluation"""
        try:
            # Only allow basic math operations
            allowed_chars = set('0123456789+-*/().= ')
            if not all(c in allowed_chars for c in expression):
                return "Error: Invalid characters in expression"
            
            result = eval(expression, {"__builtins__": {}}, {})
            return str(result)
        except Exception as e:
            return f"Calculation error: {str(e)}"
    
    def _encode_image(self, image_path: str) -> str:
        """Encode image to base64"""
        with open(image_path, "rb") as image_file:
            return base64.b64encode(image_file.read()).decode('utf-8')
    
    def chat_with_tools(self, message, user_id, chat_history=None, images: Optional[List[str]] = None):
        """
        Chat with tool calling and vision support
        
        Args:
            message: User message
            user_id: User ID
            chat_history: Previous chat history (list of dicts)
            images: List of image paths or base64 encoded images
            
        Returns:
            dict: Response with answer and tool calls
        """
        # Build conversation context
        context = ""
        if chat_history:
            for entry in chat_history[-5:]:  # Last 5 exchanges
                context += f"User: {entry.get('message', '')}\n"
                context += f"Assistant: {entry.get('response', '')}\n"
        
        # Prepare message content
        message_content = []
        
        # Add text
        if context:
            message_content.append({
                "type": "text",
                "text": f"Previous conversation:\n{context}\n\nCurrent question: {message}"
            })
        else:
            message_content.append({
                "type": "text",
                "text": message
            })
        
        # Add images if provided
        if images:
            for image in images:
                # Check if it's a file path or base64
                if os.path.exists(image):
                    # It's a file path
                    base64_image = self._encode_image(image)
                    # Determine image type from extension
                    ext = os.path.splitext(image)[1].lower()
                    mime_type = {
                        '.jpg': 'image/jpeg',
                        '.jpeg': 'image/jpeg',
                        '.png': 'image/png',
                        '.gif': 'image/gif',
                        '.webp': 'image/webp'
                    }.get(ext, 'image/jpeg')
                    
                    message_content.append({
                        "type": "image_url",
                        "image_url": {
                            "url": f"data:{mime_type};base64,{base64_image}"
                        }
                    })
                else:
                    # Assume it's already base64 or URL
                    if image.startswith('http'):
                        message_content.append({
                            "type": "image_url",
                            "image_url": {"url": image}
                        })
                    else:
                        # Assume base64
                        message_content.append({
                            "type": "image_url",
                            "image_url": {
                                "url": f"data:image/jpeg;base64,{image}"
                            }
                        })
        
        # Track tools used
        tools_used = []
        tool_results = []
        
        try:
            # Create message
            human_message = HumanMessage(content=message_content)
            
            # Get initial response
            response = self.llm.invoke([human_message])
            initial_answer = response.content
            
            # Check if tools are mentioned in the text message
            if not images:  # Only use tools for text-only queries
                for tool_name, tool_info in self.tools.items():
                    if tool_name.lower() in message.lower():
                        # Extract potential input
                        if tool_name == "web_search" and "search" in message.lower():
                            result = tool_info['func'](message)
                            tool_results.append({
                                'tool': tool_name,
                                'input': message,
                                'result': result
                            })
                            tools_used.append(tool_name)
                        elif tool_name == "api_call" and ("http://" in message or "https://" in message):
                            words = message.split()
                            url = [w for w in words if w.startswith(('http://', 'https://'))][0]
                            result = tool_info['func'](url)
                            tool_results.append({
                                'tool': tool_name,
                                'input': url,
                                'result': result
                            })
                            tools_used.append(tool_name)
                
                # Generate final response with tool results
                if tool_results:
                    tool_context = "\n".join([
                        f"Tool: {tr['tool']}\nInput: {tr['input']}\nResult: {tr['result']}"
                        for tr in tool_results
                    ])
                    
                    final_prompt = f"""Based on the tool results, answer the user's question:
                    
                    User question: {message}
                    
                    Tool results:
                    {tool_context}
                    
                    Provide a comprehensive answer incorporating the tool results:"""
                    
                    final_response = self.llm.invoke(final_prompt)
                    answer = final_response.content
                else:
                    answer = initial_answer
            else:
                answer = initial_answer
            
        except Exception as e:
            answer = f"I encountered an error: {str(e)}"
            tool_results = []
        
        # Save chat history
        chat_entry = ChatHistory(
            user_id=user_id,
            message=message,
            response=answer,
            chat_type='tool',
            extra_metadata={
                'tools_used': tools_used,
                'has_images': bool(images),
                'num_images': len(images) if images else 0,
                'tool_results': [
                    {'tool': tr['tool'], 'input': tr['input'][:200]}
                    for tr in tool_results
                ]
            }
        )
        db.session.add(chat_entry)
        db.session.commit()
        
        return {
            'answer': answer,
            'tools_used': tools_used,
            'tool_results': tool_results,
            'has_images': bool(images)
        }
    
    def get_chat_history(self, user_id, chat_type=None, limit=50):
        """
        Get chat history for user
        
        Args:
            user_id: User ID
            chat_type: Filter by chat type (rag or tool)
            limit: Maximum number of records
            
        Returns:
            list: Chat history records
        """
        query = ChatHistory.query.filter_by(user_id=user_id)
        
        if chat_type:
            query = query.filter_by(chat_type=chat_type)
        
        history = query.order_by(ChatHistory.timestamp.desc()).limit(limit).all()
        
        return [entry.to_dict() for entry in reversed(history)]
    
    def clear_chat_history(self, user_id, chat_type=None):
        """
        Clear chat history
        
        Args:
            user_id: User ID
            chat_type: Filter by chat type
            
        Returns:
            dict: Success message
        """
        query = ChatHistory.query.filter_by(user_id=user_id)
        
        if chat_type:
            query = query.filter_by(chat_type=chat_type)
        
        count = query.delete()
        db.session.commit()
        
        return {'message': f'Deleted {count} chat records'}



================================================
File: services/agentic_services/rag_service.py
================================================
import os
import uuid
from datetime import datetime
from werkzeug.utils import secure_filename
from pypdf import PdfReader
from docx import Document as DocxDocument
import chromadb
from chromadb.config import Settings
from langchain_openai import OpenAIEmbeddings, ChatOpenAI
from langchain_text_splitters import RecursiveCharacterTextSplitter
from langchain_community.vectorstores import Chroma
from langchain_community.tools import DuckDuckGoSearchRun

from models import db
from models import Document, ChatHistory

from services.auth_services.auth_service import AuthService
from configs.app_config import Config

class RAGService:
    """LangChain Agentic RAG service for document management and chat"""
    
    def __init__(self):
        """Initialize RAG service"""
        if not Config.OPENAI_API_KEY:
            raise ValueError('OpenAI API key not configured')
        
        # Initialize OpenAI embeddings
        self.embeddings = OpenAIEmbeddings(
            model="text-embedding-3-small",
            openai_api_key=Config.OPENAI_API_KEY
        )
        
        # Initialize OpenAI model
        self.llm = ChatOpenAI(
            model=Config.OPENAI_MODEL,
            openai_api_key=Config.OPENAI_API_KEY,
            temperature=0.7
        )
        
        # Initialize Chroma client
        self.chroma_client = chromadb.PersistentClient(
            path=Config.CHROMA_DB_PATH
        )
        
        # Initialize web search tool
        self.search_tool = DuckDuckGoSearchRun()
    
    def upload_document(self, file, user_id):
        """
        Upload and process document for RAG
        
        Args:
            file: File object from request
            user_id: User ID
            
        Returns:
            dict: Document data
            
        Raises:
            ValueError: If file is invalid
        """
        # Validate file
        if not file:
            raise ValueError('No file provided')
        
        filename = secure_filename(file.filename)
        if not filename:
            raise ValueError('Invalid filename')
        
        # Check file extension
        ext = filename.rsplit('.', 1)[-1].lower() if '.' in filename else ''
        if ext not in Config.ALLOWED_EXTENSIONS:
            raise ValueError(f'File type not allowed. Allowed types: {Config.ALLOWED_EXTENSIONS}')
        
        # Save file
        file_id = str(uuid.uuid4())
        filepath = os.path.join(Config.DOCUMENTS_PATH, f"{file_id}_{filename}")
        file.save(filepath)
        
        # Get file size
        file_size = os.path.getsize(filepath)
        
        # Extract text content
        try:
            text_content = self._extract_text(filepath, ext)
        except Exception as e:
            os.remove(filepath)
            raise ValueError(f'Error extracting text: {str(e)}')
        
        # Create vector store for this document
        try:
            collection_name = f"doc_{file_id}"
            vector_store = self._create_vector_store(text_content, collection_name)
        except Exception as e:
            os.remove(filepath)
            raise ValueError(f'Error creating vector store: {str(e)}')
        
        # Save document to database
        document = Document(
            filename=filename,
            filepath=filepath,
            user_id=user_id,
            vector_store_id=collection_name,
            file_size=file_size
        )
        db.session.add(document)
        db.session.commit()
        
        return document.to_dict()
    
    def _extract_text(self, filepath, ext):
        """Extract text from document"""
        text = ""
        
        if ext == 'pdf':
            reader = PdfReader(filepath)
            for page in reader.pages:
                text += page.extract_text() + "\n"
        
        elif ext in ['docx', 'doc']:
            doc = DocxDocument(filepath)
            for paragraph in doc.paragraphs:
                text += paragraph.text + "\n"
        
        elif ext in ['txt', 'md']:
            with open(filepath, 'r', encoding='utf-8') as f:
                text = f.read()
        
        else:
            raise ValueError(f'Unsupported file type: {ext}')
        
        if not text.strip():
            raise ValueError('No text content found in document')
        
        return text
    
    def _create_vector_store(self, text, collection_name):
        """Create vector store from text"""
        # Split text into chunks
        text_splitter = RecursiveCharacterTextSplitter(
            chunk_size=1000,
            chunk_overlap=200,
            length_function=len
        )
        chunks = text_splitter.split_text(text)
        
        # Create Chroma vector store
        vector_store = Chroma.from_texts(
            texts=chunks,
            embedding=self.embeddings,
            collection_name=collection_name,
            client=self.chroma_client
        )
        
        return vector_store
    
    def chat_with_documents(self, query, user_id, use_internet=False):
        """
        Chat with user's documents using RAG
        
        Args:
            query: User question
            user_id: User ID
            use_internet: Whether to use internet search
            
        Returns:
            dict: Response with answer and sources
        """
        # Get user's documents
        documents = Document.query.filter_by(user_id=user_id).all()
        
        if not documents:
            raise ValueError('No documents found. Please upload documents first.')
        
        # Combine all document collections
        all_docs = []
        for doc in documents:
            try:
                vector_store = Chroma(
                    collection_name=doc.vector_store_id,
                    embedding_function=self.embeddings,
                    client=self.chroma_client
                )
                # Retrieve relevant documents
                retrieved_docs = vector_store.similarity_search(query, k=3)
                all_docs.extend(retrieved_docs)
            except Exception as e:
                print(f"Error retrieving from {doc.filename}: {e}")
        
        if not all_docs:
            raise ValueError('Could not retrieve relevant information from documents')
        
        # Build context from documents
        context = "\n\n".join([doc.page_content for doc in all_docs])
        
        # Add internet search if enabled
        internet_info = ""
        if use_internet:
            try:
                search_results = self.search_tool.run(query)
                internet_info = f"\n\nInternet Search Results:\n{search_results}"
            except Exception as e:
                print(f"Internet search error: {e}")
        
        # Create prompt
        prompt_template = """You are a helpful AI assistant. Answer the question based on the provided context and your knowledge.
        
        Context from documents:
        {context}
        {internet_info}
        
        Question: {query}
        
        Provide a comprehensive and accurate answer. If the answer is not in the context, say so and provide general knowledge if appropriate."""
        
        prompt = prompt_template.format(
            context=context,
            internet_info=internet_info,
            query=query
        )
        
        # Generate response
        response = self.llm.invoke(prompt)
        answer = response.content
        
        # Save chat history
        chat_history = ChatHistory(
            user_id=user_id,
            message=query,
            response=answer,
            chat_type='rag',
            extra_metadata={
                'use_internet': use_internet,
                'num_sources': len(all_docs)
            }
        )
        db.session.add(chat_history)
        db.session.commit()
        
        return {
            'answer': answer,
            'sources': [
                {
                    'content': doc.page_content[:200] + '...',
                    'metadata': doc.metadata if hasattr(doc, 'metadata') else {}
                }
                for doc in all_docs[:3]
            ],
            'use_internet': use_internet
        }
    
    def get_user_documents(self, user_id):
        """Get all documents for a user"""
        documents = Document.query.filter_by(user_id=user_id).all()
        return [doc.to_dict() for doc in documents]
    
    def delete_document(self, document_id, user_id):
        """
        Delete a document
        
        Args:
            document_id: Document ID
            user_id: User ID
            
        Returns:
            dict: Success message
        """
        document = Document.query.filter_by(id=document_id, user_id=user_id).first()
        
        if not document:
            raise ValueError('Document not found')
        
        # Delete file
        try:
            if os.path.exists(document.filepath):
                os.remove(document.filepath)
        except Exception as e:
            print(f"Error deleting file: {e}")
        
        # Delete vector store collection
        try:
            self.chroma_client.delete_collection(document.vector_store_id)
        except Exception as e:
            print(f"Error deleting collection: {e}")
        
        # Delete from database
        db.session.delete(document)
        db.session.commit()
        
        return {'message': f'Document {document.filename} deleted successfully'}



================================================
File: services/auth_services/auth_service.py
================================================
from datetime import datetime, timedelta
import random
import string
from flask_jwt_extended import create_access_token

from .email_service import EmailService
from configs.app_config import Config
from models import db
from models import UserDetailsModel, RoleModel, UserRoleMappingModel

from .otp_store import OTPStore

class AuthService:
    """Authentication and Authorization Service"""
    
    @staticmethod
    def login_user(email, password, role=None):
        print("Login User",email,password,role)
        """
        Authenticate user and return token or 2FA requirement
        
        Args:
            email: User email
            password: User password
            role: Optional specific role to login as
            
        Returns:
            dict: Auth response
        """
        user = UserDetailsModel.query.filter_by(email=email).first()
        
        if not user or not user.check_password(password):
            raise ValueError('Invalid email or password')
            
        if not user.active_flag:
            raise ValueError('User account is inactive')
            
        # Check if 2FA is enabled
        if user.two_factor_auth_enabled:
            # Generate OTP
            otp = ''.join(random.choices(string.digits, k=6))
            
            # Store OTP in memory
            OTPStore().store_otp(user.email, otp, ttl_seconds=600)
            
            # Send email
            EmailService.send_otp_email(user.email, otp)
            
            return {
                'requires_2fa': True,
                'message': 'OTP sent to your email',
                'email': email # Return email to help frontend context
            }
            
        # If no 2FA, proceed to generate token
        return AuthService._generate_token_response(user, role)

    @staticmethod
    def verify_otp(email, otp, role=None):
        """
        Verify OTP and return token
        """
        user = UserDetailsModel.query.filter_by(email=email).first()
        
        if not user:
            raise ValueError('User not found')
            
        # Verify OTP from memory store
        if not OTPStore().verify_otp(email, otp):
            raise ValueError('Invalid or expired OTP')
        
        return AuthService._generate_token_response(user, role)

    @staticmethod
    def switch_domain(domain_id):
        """Switch active domain and return new token"""
        user = AuthService.get_current_user()
        if not user:
            raise ValueError('User not found')
        return AuthService._generate_token_response(user, domain_id=domain_id)

    @staticmethod
    def _generate_token_response(user, role=None, domain_id=None):
        """Generate JWT token response"""
        # Get user roles
        user_roles = user.get_role_names()
        
        if not user_roles:
            raise ValueError('User has no assigned roles')
            
        # Determine active role
        active_role = None
        
        if domain_id:
            # Find role for domain
            mapping = UserRoleMappingModel.query.filter_by(
                user_id=user.user_id,
                domain_id=domain_id,
                active_flag=True
            ).first()
            if not mapping:
                raise ValueError('User access to domain denied')
            active_role = mapping.role.role_name
        elif role:
            if role not in user_roles:
                raise ValueError(f'User does not have role: {role}')
            active_role = role
        else:
            # Default to first role (prefer admin if available)
            active_role = 'admin' if 'admin' in user_roles else user_roles[0]
            
        # Create access token
        claims = {
            'role': active_role,
            'roles': user_roles,
            'email': user.email,
            'name': user.name
        }
        if domain_id:
            claims['domain_id'] = domain_id
            
        print(f"Generating JWT Token: User={user.email}, Role={active_role}, Domain={domain_id}")
        
        access_token = create_access_token(
            identity=str(user.user_id),
            additional_claims=claims
        )
        
        return {
            'access_token': access_token,
            'user': user.to_dict(),
            'role': active_role,
            'domains': user.get_user_domains(),
            'requires_2fa': False
        }
    
    @staticmethod
    def create_user(email, password, roles=None, full_name=None, file_upload_enabled=False, two_factor_auth_enabled=False):
        """
        Create new user
        """
        if UserDetailsModel.query.filter_by(email=email).first():
            raise ValueError('Email already registered')
            
        user = UserDetailsModel(
            email=email, 
            name=full_name,
            file_upload_enabled=file_upload_enabled,
            two_factor_auth_enabled=two_factor_auth_enabled
        )
        user.set_password(password)
        db.session.add(user)
        db.session.flush() # Get ID
        
        # Assign roles
        if roles:
            AuthService.assign_roles(user.user_id, roles)
        else:
            # Default role
            AuthService.assign_roles(user.user_id, ['user'])
            
        db.session.commit()
        return user
    
    @staticmethod
    def register_user(email, password, role='user', full_name=None):
        """Register a new user (public signup)"""
        # Check if signup is enabled is handled in controller
        return AuthService.create_user(email, password, [role], full_name)

    @staticmethod
    def assign_roles(user_id, role_names):
        """Assign global roles to user (legacy support or global roles)"""
        user = UserDetailsModel.query.get(user_id)
        if not user:
            raise ValueError('User not found')
            
        # Deactivate existing roles? Or just add?
        # Original logic deactivated existing roles.
        # But now we have domain roles.
        # Let's keep it for global roles (domain_id=None).
        
        for role_name in role_names:
            role = RoleModel.query.filter_by(role_name=role_name).first()
            if not role:
                continue
                
            # Check if mapping exists
            mapping = UserRoleMappingModel.query.filter_by(
                user_id=user.user_id,
                role_id=role.role_id,
                domain_id=None
            ).first()
            
            if mapping:
                mapping.active_flag = True
            else:
                mapping = UserRoleMappingModel(
                    user_id=user.user_id,
                    role_id=role.role_id,
                    domain_id=None,
                    active_flag=True
                )
                db.session.add(mapping)
                
        db.session.commit()

    @staticmethod
    def assign_domain_role(user_id, role_name, domain_id):
        """Assign a role to a user for a specific domain"""
        user = UserDetailsModel.query.get(user_id)
        if not user:
            raise ValueError('User not found')
            
        role = RoleModel.query.filter_by(role_name=role_name).first()
        if not role:
            raise ValueError(f'Role {role_name} not found')
            
        # Check if mapping exists
        mapping = UserRoleMappingModel.query.filter_by(
            user_id=user.user_id,
            role_id=role.role_id,
            domain_id=domain_id
        ).first()
        
        if mapping:
            mapping.active_flag = True
        else:
            mapping = UserRoleMappingModel(
                user_id=user.user_id,
                role_id=role.role_id,
                domain_id=domain_id,
                active_flag=True
            )
            db.session.add(mapping)
        db.session.commit()

    @staticmethod
    def get_current_user():
        """Get current authenticated user"""
        from flask_jwt_extended import get_jwt_identity
        user_id = get_jwt_identity()
        return UserDetailsModel.query.get(user_id)

    @staticmethod
    def verify_admin():
        """Verify current user is admin"""
        user = AuthService.get_current_user()
        if not user or not user.is_admin():
            raise ValueError('Admin access required')
        return user

    @staticmethod
    def verify_platform_admin():
        """Verify current user is Platform Admin"""
        user = AuthService.get_current_user()
        # Assuming 'Platform Admin' is the role name.
        # Or check if they have 'Platform Admin' role globally (domain_id=None)
        if not user or not user.has_role('Platform Admin'):
             raise ValueError('Platform Admin access required')
        return user
        
    @staticmethod
    def check_user_exists(email):
        """Check if user exists and return their roles"""
        user = UserDetailsModel.query.filter_by(email=email).first()
        if user:
            return {
                'exists': True,
                'roles': user.get_role_names()  # Return all roles, not just first
            }
        return {'exists': False, 'roles': []}



================================================
File: services/auth_services/email_service.py
================================================
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from configs.app_config import Config

class EmailService:
    """Service for sending emails"""
    
    @staticmethod
    def send_otp_email(to_email, otp):
        """
        Send OTP email to user
        
        Args:
            to_email: Recipient email
            otp: One Time Password
            
        Returns:
            bool: True if sent successfully
        """
        if not Config.SMTP_USERNAME or not Config.SMTP_PASSWORD:
            print("SMTP credentials not configured. OTP: ", otp)
            return False
            
        try:
            msg = MIMEMultipart()
            msg['From'] = Config.SMTP_SENDER_EMAIL
            msg['To'] = to_email
            msg['Subject'] = "Your Login OTP"
            
            body = f"""
            <html>
                <body>
                    <h2>Login Verification</h2>
                    <p>Your One Time Password (OTP) is:</p>
                    <h1>{otp}</h1>
                    <p>This OTP is valid for 5 minutes.</p>
                    <p>If you did not request this, please ignore this email.</p>
                </body>
            </html>
            """
            
            msg.attach(MIMEText(body, 'html'))
            
            server = smtplib.SMTP(Config.SMTP_SERVER, Config.SMTP_PORT)
            server.starttls()
            server.login(Config.SMTP_USERNAME, Config.SMTP_PASSWORD)
            text = msg.as_string()
            server.sendmail(Config.SMTP_SENDER_EMAIL, to_email, text)
            server.quit()
            
            return True
        except Exception as e:
            print(f"Failed to send email: {e}")
            # For dev/testing if email fails, print OTP
            print(f"DEV MODE OTP: {otp}")
            return False



================================================
File: services/auth_services/otp_store.py
================================================
import time
from typing import Dict, Any, Optional

class OTPStore:
    """
    Singleton in-memory store for OTPs.
    Stores OTPs with an expiration time.
    """
    _instance = None
    _store: Dict[str, Dict[str, Any]] = {}

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(OTPStore, cls).__new__(cls)
            cls._store = {}
        return cls._instance

    def store_otp(self, key: str, otp: str, ttl_seconds: int = 600):
        """
        Store an OTP for a given key (e.g., email or user_id).
        :param key: The identifier for the user/request.
        :param otp: The OTP string.
        :param ttl_seconds: Time to live in seconds (default 10 minutes).
        """
        expires_at = time.time() + ttl_seconds
        self._store[key] = {
            'otp': otp,
            'expires_at': expires_at
        }
        self.cleanup() # Opportunistic cleanup

    def verify_otp(self, key: str, otp: str) -> bool:
        """
        Verify if the provided OTP matches the stored one and is not expired.
        :param key: The identifier.
        :param otp: The OTP to verify.
        :return: True if valid, False otherwise.
        """
        record = self._store.get(key)
        if not record:
            return False

        if time.time() > record['expires_at']:
            del self._store[key]
            return False

        if record['otp'] == otp:
            del self._store[key] # Consume OTP
            return True
        
        return False

    def cleanup(self):
        """Remove expired OTPs."""
        now = time.time()
        keys_to_remove = [k for k, v in self._store.items() if now > v['expires_at']]
        for k in keys_to_remove:
            del self._store[k]



================================================
File: services/guardrails_services/guardrails_service.py
================================================
import re
from datetime import datetime
from models import db
from models import GuardrailsConfig, GuardrailsLog
from services.auth_services.auth_service import AuthService
from configs.app_config import Config

class GuardrailsService:
    """LangChain middleware for guardrails and content moderation"""
    
    # Default guardrails rules
    DEFAULT_RULES = [
        {
            'rule_type': 'PII_EMAIL',
            'enabled': True,
            'severity': 'high',
            'description': 'Detect email addresses in content',
            'pattern': r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
        },
        {
            'rule_type': 'PII_PHONE',
            'enabled': True,
            'severity': 'high',
            'description': 'Detect phone numbers',
            'pattern': r'\b\d{3}[-.]?\d{3}[-.]?\d{4}\b'
        },
        {
            'rule_type': 'PII_SSN',
            'enabled': True,
            'severity': 'high',
            'description': 'Detect Social Security Numbers',
            'pattern': r'\b\d{3}-\d{2}-\d{4}\b'
        },
        {
            'rule_type': 'PROFANITY',
            'enabled': True,
            'severity': 'medium',
            'description': 'Detect profanity and offensive language',
            'pattern': r'\b(fuck|shit|damn|bitch|ass|bastard|crap)\b'
        },
        {
            'rule_type': 'VIOLENCE',
            'enabled': True,
            'severity': 'high',
            'description': 'Detect violent content',
            'pattern': r'\b(kill|murder|shoot|stab|attack|harm|hurt|destroy)\b'
        },
        {
            'rule_type': 'FINANCIAL',
            'enabled': True,
            'severity': 'medium',
            'description': 'Detect credit card numbers',
            'pattern': r'\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b'
        },
        {
            'rule_type': 'PROMPT_INJECTION',
            'enabled': True,
            'severity': 'high',
            'description': 'Detect prompt injection attempts',
            'pattern': r'\b(ignore|disregard|forget).*?(previous|above|prior)\s+(instructions|prompt|context)\b'
        }
    ]
    
    @staticmethod
    def initialize_defaults():
        """Initialize default guardrails rules in database"""
        for rule in GuardrailsService.DEFAULT_RULES:
            existing = GuardrailsConfig.query.filter_by(rule_type=rule['rule_type']).first()
            if not existing:
                config = GuardrailsConfig(**rule)
                db.session.add(config)
        
        db.session.commit()
    
    @staticmethod
    def check_content(content, user_id, check_type='both'):
        """
        Check content against guardrails
        
        Args:
            content: Content to check
            user_id: User ID
            check_type: 'input', 'output', or 'both'
            
        Returns:
            dict: Check results with violations and cleaned content
        """
        if not Config.GUARDRAILS_ENABLED:
            return {
                'passed': True,
                'violations': [],
                'cleaned_content': content
            }
        
        # Get enabled rules
        rules = GuardrailsConfig.query.filter_by(enabled=True).all()
        
        violations = []
        cleaned_content = content
        
        for rule in rules:
            if rule.pattern:
                matches = re.finditer(rule.pattern, content, re.IGNORECASE)
                for match in matches:
                    violation = {
                        'rule_type': rule.rule_type,
                        'severity': rule.severity,
                        'matched_text': match.group(),
                        'position': match.span()
                    }
                    violations.append(violation)
                    
                    # Log violation
                    log_entry = GuardrailsLog(
                        user_id=user_id,
                        guardrail_id=rule.id,
                        detected_rule=rule.rule_type,
                        content_snippet=match.group()[:200],
                        action_taken='blocked' if rule.severity == 'high' else 'warned'
                    )
                    db.session.add(log_entry)
                    
                    # Redact high severity violations
                    if rule.severity == 'high':
                        cleaned_content = cleaned_content.replace(
                            match.group(),
                            '[REDACTED]'
                        )
        
        db.session.commit()
        
        # Determine if content passes
        high_severity = [v for v in violations if v['severity'] == 'high']
        passed = len(high_severity) == 0
        
        return {
            'passed': passed,
            'violations': violations,
            'cleaned_content': cleaned_content,
            'action': 'blocked' if not passed else 'allowed'
        }
    
    @staticmethod
    def get_guardrails_config():
        """Get all guardrails configuration"""
        rules = GuardrailsConfig.query.all()
        return [rule.to_dict() for rule in rules]
    
    @staticmethod
    def update_guardrail(rule_id, enabled=None, severity=None, description=None, pattern=None):
        """
        Update guardrail configuration (admin only)
        
        Args:
            rule_id: Rule ID
            enabled: Enable/disable rule
            severity: Rule severity
            description: Rule description
            pattern: Regex pattern
            
        Returns:
            dict: Updated rule
        """
        rule = GuardrailsConfig.query.get(rule_id)
        
        if not rule:
            raise ValueError('Guardrail rule not found')
        
        if enabled is not None:
            rule.enabled = enabled
        
        if severity:
            rule.severity = severity
        
        if description:
            rule.description = description
        
        if pattern:
            # Validate regex pattern
            try:
                re.compile(pattern)
                rule.pattern = pattern
            except re.error:
                raise ValueError('Invalid regex pattern')
        
        db.session.commit()
        
        return rule.to_dict()
    
    @staticmethod
    def create_guardrail(rule_type, enabled=True, severity='medium', description='', pattern=''):
        """
        Create new guardrail rule (admin only)
        
        Args:
            rule_type: Rule type identifier
            enabled: Enable/disable rule
            severity: Rule severity
            description: Rule description
            pattern: Regex pattern
            
        Returns:
            dict: Created rule
        """
        # Check if rule type already exists
        existing = GuardrailsConfig.query.filter_by(rule_type=rule_type).first()
        if existing:
            raise ValueError(f'Rule type {rule_type} already exists')
        
        # Validate pattern if provided
        if pattern:
            try:
                re.compile(pattern)
            except re.error:
                raise ValueError('Invalid regex pattern')
        
        rule = GuardrailsConfig(
            rule_type=rule_type,
            enabled=enabled,
            severity=severity,
            description=description,
            pattern=pattern
        )
        
        db.session.add(rule)
        db.session.commit()
        
        return rule.to_dict()
    
    @staticmethod
    def delete_guardrail(rule_id):
        """Delete guardrail rule (admin only)"""
        rule = GuardrailsConfig.query.get(rule_id)
        
        if not rule:
            raise ValueError('Guardrail rule not found')
        
        db.session.delete(rule)
        db.session.commit()
        
        return {'message': f'Guardrail rule {rule.rule_type} deleted'}
    
    @staticmethod
    def get_guardrails_logs(user_id=None, limit=100):
        """
        Get guardrails detection logs (admin only)
        
        Args:
            user_id: Filter by specific user
            limit: Maximum number of logs
            
        Returns:
            list: Guardrails logs
        """
        query = GuardrailsLog.query
        
        if user_id:
            query = query.filter_by(user_id=user_id)
        
        logs = query.order_by(GuardrailsLog.timestamp.desc()).limit(limit).all()
        
        return [log.to_dict() for log in logs]
    
    @staticmethod
    def toggle_guardrails(enabled):
        """
        Toggle all guardrails on/off (admin only)
        
        Args:
            enabled: True to enable, False to disable
            
        Returns:
            dict: Status message
        """
        # This would update the config, but we'll use the Config.GUARDRAILS_ENABLED
        # In a production system, this would update a database setting
        return {
            'enabled': enabled,
            'message': f'Guardrails {"enabled" if enabled else "disabled"}. Note: Update GUARDRAILS_ENABLED in config.'
        }



================================================
File: services/system_services/domain_service.py
================================================
from models import db, DomainModel, UserRoleMappingModel, UserDetailsModel

class DomainService:
    ALLOWED_DOMAIN_TYPES = ['Agentic', 'Guardrails', 'Custom']
    
    @staticmethod
    def initialize_default_domains():
        """Initialize default Agentic and Guardrails domains"""
        defaults = [
            {'domain_name': 'Agentic Domain', 'domain_type': 'Agentic', 'description': 'AI-powered document chat and tool calling domain'},
            {'domain_name': 'Guardrails Domain', 'domain_type': 'Guardrails', 'description': 'Security and safety guardrails domain'},
        ]
        
        for domain_data in defaults:
            if not DomainModel.query.filter_by(domain_name=domain_data['domain_name']).first():
                domain = DomainModel(**domain_data)
                db.session.add(domain)
        
        db.session.commit()
    
    @staticmethod
    def create_domain(domain_name, description=None, domain_type='Agentic'):
        if DomainModel.query.filter_by(domain_name=domain_name).first():
            raise ValueError(f"Domain '{domain_name}' already exists")
        
        if domain_type not in DomainService.ALLOWED_DOMAIN_TYPES:
            raise ValueError(f"Invalid domain type. Allowed: {', '.join(DomainService.ALLOWED_DOMAIN_TYPES)}")
        
        domain = DomainModel(
            domain_name=domain_name, 
            description=description,
            domain_type=domain_type
        )
        db.session.add(domain)
        db.session.commit()
        return domain

    @staticmethod
    def get_all_domains():
        return DomainModel.query.filter_by(active_flag=True).all()

    @staticmethod
    def get_domain_by_id(domain_id):
        domain = DomainModel.query.get(domain_id)
        if not domain:
            raise ValueError("Domain not found")
        return domain

    @staticmethod
    def get_domain_users(domain_id):
        """Get all users assigned to a specific domain"""
        mappings = UserRoleMappingModel.query.filter_by(
            domain_id=domain_id, 
            active_flag=True
        ).all()
        
        users = []
        seen_user_ids = set()
        for mapping in mappings:
            if mapping.user_id not in seen_user_ids:
                user = UserDetailsModel.query.get(mapping.user_id)
                if user:
                    users.append({
                        'user_id': user.user_id,
                        'name': user.name,
                        'email': user.email,
                        'role': mapping.role.role_name
                    })
                    seen_user_ids.add(mapping.user_id)
        
        return users

    @staticmethod
    def update_domain(domain_id, data):
        domain = DomainModel.query.get(domain_id)
        if not domain:
            raise ValueError("Domain not found")
        
        if 'domain_name' in data:
            existing = DomainModel.query.filter_by(domain_name=data['domain_name']).first()
            if existing and existing.domain_id != domain_id:
                raise ValueError(f"Domain '{data['domain_name']}' already exists")
            domain.domain_name = data['domain_name']
        
        if 'description' in data:
            domain.description = data['description']
        
        if 'domain_type' in data:
            if data['domain_type'] not in DomainService.ALLOWED_DOMAIN_TYPES:
                raise ValueError(f"Invalid domain type. Allowed: {', '.join(DomainService.ALLOWED_DOMAIN_TYPES)}")
            domain.domain_type = data['domain_type']
            
        if 'active_flag' in data:
            domain.active_flag = data['active_flag']
            
        db.session.commit()
        return domain

    @staticmethod
    def delete_domain(domain_id):
        domain = DomainModel.query.get(domain_id)
        if not domain:
            raise ValueError("Domain not found")
        
        # Check if domain has users
        user_count = UserRoleMappingModel.query.filter_by(domain_id=domain_id, active_flag=True).count()
        if user_count > 0:
            raise ValueError(f"Cannot delete domain with {user_count} active users. Remove all users first.")
        
        db.session.delete(domain)
        db.session.commit()
        return {'message': f"Domain '{domain.domain_name}' deleted successfully"}



================================================
File: services/system_services/user_service.py
================================================
from models import db, UserDetailsModel
from services.auth_services.auth_service import AuthService

class UserService:
    """Service for managing users"""
    
    @staticmethod
    def get_all_users():
        """Get all users, filtered by domain access"""
        current_user = AuthService.get_current_user()
        if not current_user:
            raise ValueError('Authentication required')
            
        # If Platform Admin, return all
        # Assuming has_role method exists and checks role name
        if current_user.has_role('Platform Admin'):
             users = UserDetailsModel.query.all()
             return [user.to_dict() for user in users]
             
        # Get domains where current user is Admin
        admin_domains = []
        for mapping in current_user.user_roles:
            if mapping.active_flag and mapping.domain_id and mapping.role.role_name == 'admin':
                admin_domains.append(mapping.domain_id)
                
        if not admin_domains:
            # If not admin of any domain, check if global admin
            if current_user.is_admin(): 
                users = UserDetailsModel.query.all()
                return [user.to_dict() for user in users]
            return []
            
        # Find users who have roles in these domains
        from models import UserRoleMappingModel
        users = UserDetailsModel.query.join(UserRoleMappingModel).filter(
            UserRoleMappingModel.domain_id.in_(admin_domains),
            UserRoleMappingModel.active_flag == True
        ).distinct().all()
        
        return [user.to_dict() for user in users]
    
    @staticmethod
    def get_user_by_id(user_id):
        """Get user by ID"""
        user = UserDetailsModel.query.get(user_id)
        if not user:
            raise ValueError('User not found')
        return user.to_dict()
    
    @staticmethod
    def update_user(user_id, data):
        """
        Update user details
        
        Args:
            user_id: User ID
            data: Dict with update data
            
        Returns:
            dict: Updated user data
        """
        user = UserDetailsModel.query.get(user_id)
        if not user:
            raise ValueError('User not found')
            
        if 'full_name' in data:
            user.name = data['full_name']
            
        if 'file_upload_enabled' in data:
            user.file_upload_enabled = data['file_upload_enabled']
            
        if 'two_factor_auth_enabled' in data:
            user.two_factor_auth_enabled = data['two_factor_auth_enabled']
            
        # Handle role updates
        # Support both 'role' (single, legacy) and 'roles' (list, new)
        roles_to_assign = None
        if 'roles' in data and data['roles']:
            roles_to_assign = data['roles']
        elif 'role' in data and data['role']:
            roles_to_assign = [data['role']]
            
        if roles_to_assign:
            AuthService.assign_roles(user.user_id, roles_to_assign)
            
        db.session.commit()
        return user.to_dict()
    
    @staticmethod
    def delete_user(user_id):
        """Delete user"""
        user = UserDetailsModel.query.get(user_id)
        if not user:
            raise ValueError('User not found')
            
        # Prevent deleting last admin
        if user.is_admin():
            admin_count = 0
            all_users = UserDetailsModel.query.all()
            for u in all_users:
                if u.is_admin():
                    admin_count += 1
            
            if admin_count <= 1:
                raise ValueError('Cannot delete the last administrator')
        
        db.session.delete(user)
        db.session.commit()
        return {'message': 'User deleted successfully'}
    
    @staticmethod
    def get_users_by_domain(domain_id):
        """Get all users assigned to a specific domain"""
        from models import UserRoleMappingModel
        
        mappings = UserRoleMappingModel.query.filter_by(
            domain_id=domain_id,
            active_flag=True
        ).all()
        
        users = []
        seen_user_ids = set()
        for mapping in mappings:
            if mapping.user_id not in seen_user_ids:
                user = UserDetailsModel.query.get(mapping.user_id)
                if user:
                    user_dict = user.to_dict()
                    user_dict['domain_role'] = mapping.role.role_name
                    users.append(user_dict)
                    seen_user_ids.add(mapping.user_id)
        
        return users
    
    @staticmethod
    def assign_user_to_domain(user_id, domain_id, role_name='user'):
        """Assign a user to a domain with a specific role"""
        user = UserDetailsModel.query.get(user_id)
        if not user:
            raise ValueError('User not found')
        
        # Use AuthService to assign domain role
        AuthService.assign_domain_role(user_id, role_name, domain_id)
        
        return {'message': f'User {user.email} assigned to domain with role {role_name}'}
    
    @staticmethod
    def remove_user_from_domain(user_id, domain_id):
        """Remove a user from a domain"""
        from models import UserRoleMappingModel
        
        user = UserDetailsModel.query.get(user_id)
        if not user:
            raise ValueError('User not found')
        
        # Deactivate all role mappings for this user in this domain
        mappings = UserRoleMappingModel.query.filter_by(
            user_id=user_id,
            domain_id=domain_id
        ).all()
        
        if not mappings:
            raise ValueError('User not assigned to this domain')
        
        for mapping in mappings:
            mapping.active_flag = False
        
        db.session.commit()
        return {'message': f'User {user.email} removed from domain'}



================================================
File: services/ui_services/component_service.py
================================================
from models import db
from models import ComponentModel, ComponentRoleMappingModel, RoleModel
from services.auth_services.auth_service import AuthService

class ComponentService:
    """Component/View management service"""
    
    @staticmethod
    def get_available_components():
        """
        Get list of all available components from database
        
        Returns:
            dict: Components categorized by type (simplified for now)
        """
        # Fetch all active components
        components = ComponentModel.query.filter_by(active_flag=True).all()
        
        # For backward compatibility, we'll categorize them
        # Ideally, we should have a 'type' or 'category' field in ComponentModel
        # For now, we'll just return all as assignable
        component_names = [c.template_name for c in components]
        
        return {
            'assignable': component_names,
            'admin_only': [] # Deprecated concept, controlled by roles now
        }
    
    @staticmethod
    def get_user_components():
        """
        Get components accessible by current user
        
        Returns:
            list: List of accessible component names
        """
        user = AuthService.get_current_user()
        
        # Get components accessible by any of user's roles
        accessible_components = set()
        
        for user_role in user.user_roles:
            if not user_role.active_flag:
                continue
                
            role = user_role.role
            # Get component mappings for this role
            mappings = ComponentRoleMappingModel.query.filter_by(
                role_id=role.role_id,
                active_flag=True
            ).all()
            
            for mapping in mappings:
                if mapping.template and mapping.template.active_flag:
                    accessible_components.add(mapping.template.template_name)
        
        return list(accessible_components)
    
    @staticmethod
    def get_role_components(role_name):
        """
        Get components accessible by a specific role
        
        Args:
            role_name: Role name
            
        Returns:
            list: List of accessible component names
        """
        role = RoleModel.query.filter_by(role_name=role_name).first()
        if not role:
            raise ValueError(f'Role not found: {role_name}')
        
        # Get role's assigned components
        mappings = ComponentRoleMappingModel.query.filter_by(
            role_id=role.role_id,
            active_flag=True
        ).all()
        
        components = []
        for mapping in mappings:
            if mapping.template and mapping.template.active_flag:
                components.append(mapping.template.template_name)
                
        return components
    
    @staticmethod
    def assign_component_to_role(role_name, component_name, has_access=True):
        """
        Assign or remove component access for a role (admin only)
        
        Args:
            role_name: Role name
            component_name: Component name (template_name)
            has_access: Whether to grant or revoke access (sets active_flag)
            
        Returns:
            dict: Updated access record
        """
        # Get role
        role = RoleModel.query.filter_by(role_name=role_name).first()
        if not role:
            raise ValueError(f'Role not found: {role_name}')
        
        # Find template
        template = ComponentModel.query.filter_by(template_name=component_name).first()
        if not template:
            # Dynamic creation if not exists? 
            # For now, assume it must exist. If we want dynamic creation, we need more info (mode, value)
            raise ValueError(f'Component template not found: {component_name}')
        
        # Find or create access record
        mapping = ComponentRoleMappingModel.query.filter_by(
            role_id=role.role_id,
            template_id=template.template_id
        ).first()
        
        if mapping:
            mapping.active_flag = has_access
        else:
            mapping = ComponentRoleMappingModel(
                role_id=role.role_id,
                template_id=template.template_id,
                active_flag=has_access
            )
            db.session.add(mapping)
        
        db.session.commit()
        
        return mapping.to_dict()
    
    @staticmethod
    def bulk_assign_components(role_name, component_assignments):
        """
        Bulk assign components to a role
        """
        results = []
        for component_name, has_access in component_assignments.items():
            try:
                result = ComponentService.assign_component_to_role(
                    role_name, component_name, has_access
                )
                results.append(result)
            except ValueError as e:
                results.append({'component_name': component_name, 'error': str(e)})
        return results
    
    @staticmethod
    def get_navigation(active_role: str, domain_id=None):
        try:
            """
            Return navigation items for the ACTIVE ROLE (from JWT) filtered by domain.
            Uses efficient JOINs instead of multiple DB queries.
            """
            from flask_jwt_extended import get_jwt

            # Get domain_id from JWT claims if not provided
            if domain_id is None:
                claims = get_jwt()
                domain_id = claims.get('domain_id')

            # Fetch the role record
            role = RoleModel.query.filter_by(role_name=active_role, active_flag=True).first()
            if not role:
                return []

            # Build query with domain filter
            query = (
                db.session.query(ComponentModel)
                .join(ComponentRoleMappingModel, ComponentRoleMappingModel.template_id == ComponentModel.template_id)
                .filter(
                    ComponentRoleMappingModel.role_id == role.role_id,
                    ComponentRoleMappingModel.active_flag == True,
                    ComponentModel.active_flag == True
                )
            )

            # Add domain filter
            if domain_id is not None:
                query = query.filter(ComponentModel.domain_id == domain_id)
            else:
                # Platform Admin or global roles - show components with no domain
                query = query.filter(ComponentModel.domain_id.is_(None))

            results = query.all()

            # Convert results to navigation structure
            nav_items = []
            for template in results:
                nav_items.append({
                    'name': template.template_name,
                    'label': template.template_name,
                    'icon': template.template_icon or '🔐', 
                    'description': template.description,
                    'admin_only': False,
                    'mode': template.component_mode,
                    'value': template.component_value,
                    'domain_id': template.domain_id
                })

            return nav_items

        except Exception as e:
            import traceback
            print(f"Navigation error: {str(e)}")
            print(traceback.format_exc())
            return []

    @staticmethod
    def get_navigation_for_user():
        """
        Get navigation menu items for the current authenticated user.
        Filters components based on user's roles.
        
        Returns:
            list: List of navigation items with metadata
        """
        user = AuthService.get_current_user()
        
        # Get all active templates
        templates = ComponentModel.query.filter_by(active_flag=True).all()
        
        nav_items = []
        for template in templates:
            # Check access
            has_access = False
            
            # Check if user has access via their roles
            for user_role in user.user_roles:
                if not user_role.active_flag:
                    continue
                
                mapping = ComponentRoleMappingModel.query.filter_by(
                    role_id=user_role.role_id,
                    template_id=template.template_id,
                    active_flag=True
                ).first()
                
                if mapping:
                    has_access = True
                    break
            
            # Add to navigation if user has access
            if has_access:
                nav_items.append({
                    'name': template.template_name,
                    'label': template.template_name, 
                    'icon': 'extension', # Default icon, could be stored in DB if we add a column
                    'description': template.description,
                    'admin_only': False, # Deprecated concept
                    'mode': template.component_mode,
                    'value': template.component_value
                })
        
        return nav_items
    
    @staticmethod
    def verify_component_access(component_name):
        """
        Verify current user has access to a component
        """
        user = AuthService.get_current_user()
        
        # Find template
        template = ComponentModel.query.filter_by(template_name=component_name).first()
        if not template or not template.active_flag:
             raise ValueError(f'Component not found or inactive: {component_name}')

        # Check access records for all user's roles
        for user_role in user.user_roles:
            if not user_role.active_flag:
                continue
                
            mapping = ComponentRoleMappingModel.query.filter_by(
                role_id=user_role.role_id,
                template_id=template.template_id,
                active_flag=True
            ).first()
            
            if mapping:
                return True
        
        raise ValueError(f'Access denied to component: {component_name}')
    
    @staticmethod
    def get_components_by_domain(domain_id=None):
        """Get all components for a specific domain"""
        if domain_id is None:
            # Return components with no domain (Platform Admin components)
            components = ComponentModel.query.filter_by(active_flag=True).filter(
                ComponentModel.domain_id.is_(None)
            ).all()
        else:
            components = ComponentModel.query.filter_by(
                domain_id=domain_id,
                active_flag=True
            ).all()
        
        return [c.to_dict() for c in components]



================================================
File: utils/api_utils.py
================================================
from flask_smorest import Api
from flask import Flask

def api_register(api: Api, blueprints: list):
    """
    Register a list of blueprints with the Flask-Smorest API instance.
    
    Args:
        api (Api): The Flask-Smorest API instance.
        blueprints (list): A list of Blueprint objects to register.
    """
    for blueprint in blueprints:
        api.register_blueprint(blueprint)



================================================
File: utils/marshmallow_utils.py
================================================
from flask_restx import fields as restx_fields
from marshmallow import fields as ma_fields
from marshmallow import Schema

def marshmallow_to_restx_model(api, schema_cls, model_name=None):
    """
    Convert a Marshmallow Schema class to a Flask-RestX Model.
    
    Args:
        api: The Flask-RestX Api or Namespace instance.
        schema_cls: The Marshmallow Schema class.
        model_name: Optional name for the model. If None, uses schema class name.
        
    Returns:
        A Flask-RestX Model.
    """
    if not model_name:
        model_name = schema_cls.__name__.replace('Schema', '')
        
    model_fields = {}
    
    # Instantiate schema to get fields
    schema = schema_cls()
    
    for field_name, field in schema.fields.items():
        restx_field = _convert_field(field, api)
        if restx_field:
            model_fields[field_name] = restx_field
            
    return api.model(model_name, model_fields)

def _convert_field(field, api):
    """Helper to convert a single Marshmallow field to RestX field."""
    if isinstance(field, ma_fields.Nested):
        # Handle nested schemas
        nested_schema = field.nested
        if isinstance(nested_schema, str):
            # Handle string reference if needed, but usually it's a class or instance
            # For simplicity, assume it's a class or instance we can inspect
            # This might be complex if it's a string 'Self' etc.
            return restx_fields.Raw() 
        
        if isinstance(nested_schema, type) and issubclass(nested_schema, Schema):
            nested_model = marshmallow_to_restx_model(api, nested_schema)
        elif isinstance(nested_schema, Schema):
            nested_model = marshmallow_to_restx_model(api, type(nested_schema))
        else:
            return restx_fields.Raw()
            
        if field.many:
            return restx_fields.List(restx_fields.Nested(nested_model))
        else:
            return restx_fields.Nested(nested_model)
            
    if isinstance(field, ma_fields.List):
        inner_field = _convert_field(field.inner, api)
        if inner_field:
            return restx_fields.List(inner_field)
        return restx_fields.List(restx_fields.String)
        
    if isinstance(field, ma_fields.Integer):
        return restx_fields.Integer(description=field.metadata.get('description'), required=field.required)
    if isinstance(field, ma_fields.Boolean):
        return restx_fields.Boolean(description=field.metadata.get('description'), required=field.required)
    if isinstance(field, ma_fields.Float):
        return restx_fields.Float(description=field.metadata.get('description'), required=field.required)
    if isinstance(field, ma_fields.Number):
        return restx_fields.Float(description=field.metadata.get('description'), required=field.required)
    if isinstance(field, ma_fields.Date):
        return restx_fields.Date(description=field.metadata.get('description'), required=field.required)
    if isinstance(field, ma_fields.DateTime):
        return restx_fields.DateTime(description=field.metadata.get('description'), required=field.required)
    if isinstance(field, ma_fields.String):
        return restx_fields.String(description=field.metadata.get('description'), required=field.required)
    if isinstance(field, ma_fields.Dict):
        return restx_fields.Raw(description=field.metadata.get('description'), required=field.required)
    if isinstance(field, ma_fields.Raw):
        return restx_fields.Raw(description=field.metadata.get('description'), required=field.required)
        
    # Default to String for unknown types
    return restx_fields.String(description=field.metadata.get('description'), required=field.required)


